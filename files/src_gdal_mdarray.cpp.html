<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/gdal_mdarray.cpp - node-gdal-async</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-async" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-async">
            node-gdal-async
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>3.3.1</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DIM)", "classes/Constants (DIR)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.ArrayAttributes", "classes/gdal.ArrayDimensions", "classes/gdal.Attribute", "classes/gdal.CircularString", "classes/gdal.CompoundCurve", "classes/gdal.CompoundCurveCurves", "classes/gdal.config", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Dimension", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Group", "classes/gdal.GroupArrays", "classes/gdal.GroupAttributes", "classes/gdal.GroupDimensions", "classes/gdal.GroupGroups", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MDArray", "classes/gdal.MultiCurve", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.SimpleCurve", "classes/gdal.SpatialReference"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DIM).html">Constants (DIM)</a></li>
                <li><a href="../classes/Constants (DIR).html">Constants (DIR)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.ArrayAttributes.html">gdal.ArrayAttributes</a></li>
                <li><a href="../classes/gdal.ArrayDimensions.html">gdal.ArrayDimensions</a></li>
                <li><a href="../classes/gdal.Attribute.html">gdal.Attribute</a></li>
                <li><a href="../classes/gdal.CircularString.html">gdal.CircularString</a></li>
                <li><a href="../classes/gdal.CompoundCurve.html">gdal.CompoundCurve</a></li>
                <li><a href="../classes/gdal.CompoundCurveCurves.html">gdal.CompoundCurveCurves</a></li>
                <li><a href="../classes/gdal.config.html">gdal.config</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Dimension.html">gdal.Dimension</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Group.html">gdal.Group</a></li>
                <li><a href="../classes/gdal.GroupArrays.html">gdal.GroupArrays</a></li>
                <li><a href="../classes/gdal.GroupAttributes.html">gdal.GroupAttributes</a></li>
                <li><a href="../classes/gdal.GroupDimensions.html">gdal.GroupDimensions</a></li>
                <li><a href="../classes/gdal.GroupGroups.html">gdal.GroupGroups</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MDArray.html">gdal.MDArray</a></li>
                <li><a href="../classes/gdal.MultiCurve.html">gdal.MultiCurve</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.SimpleCurve.html">gdal.SimpleCurve</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/gdal_mdarray.cpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
#include &quot;gdal_mdarray.hpp&quot;
#include &quot;gdal_group.hpp&quot;
#include &quot;gdal_common.hpp&quot;
#include &quot;gdal_driver.hpp&quot;
#include &quot;collections/array_dimensions.hpp&quot;
#include &quot;collections/array_attributes.hpp&quot;
#include &quot;geometry/gdal_geometry.hpp&quot;
#include &quot;gdal_layer.hpp&quot;
#include &quot;gdal_majorobject.hpp&quot;
#include &quot;gdal_spatial_reference.hpp&quot;
#include &quot;utils/typed_array.hpp&quot;

namespace node_gdal {

#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)

Nan::Persistent&lt;FunctionTemplate&gt; MDArray::constructor;

void MDArray::Initialize(Local&lt;Object&gt; target) {
  Nan::HandleScope scope;

  Local&lt;FunctionTemplate&gt; lcons = Nan::New&lt;FunctionTemplate&gt;(MDArray::New);
  lcons-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  lcons-&gt;SetClassName(Nan::New(&quot;MDArray&quot;).ToLocalChecked());

  Nan::SetPrototypeMethod(lcons, &quot;toString&quot;, toString);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;read&quot;, read);
  Nan::SetPrototypeMethod(lcons, &quot;getView&quot;, getView);
  Nan::SetPrototypeMethod(lcons, &quot;getMask&quot;, getMask);
  Nan::SetPrototypeMethod(lcons, &quot;asDataset&quot;, asDataset);

  ATTR_DONT_ENUM(lcons, &quot;_uid&quot;, uidGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;srs&quot;, srsGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;dataType&quot;, typeGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;length&quot;, lengthGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;unitType&quot;, unitTypeGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;scale&quot;, scaleGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;offset&quot;, offsetGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;noDataValue&quot;, noDataValueGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;description&quot;, descriptionGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;dimensions&quot;, dimensionsGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;attributes&quot;, attributesGetter, READ_ONLY_SETTER);

  Nan::Set(target, Nan::New(&quot;MDArray&quot;).ToLocalChecked(), Nan::GetFunction(lcons).ToLocalChecked());

  constructor.Reset(lcons);
}

MDArray::MDArray(std::shared_ptr&lt;GDALMDArray&gt; md) : Nan::ObjectWrap(), uid(0), this_(md) {
  LOG(&quot;Created MDArray [%p]&quot;, md.get());
}

MDArray::~MDArray() {
  dispose();
}

void MDArray::dispose() {
  if (this_) {

    LOG(&quot;Disposing array [%p]&quot;, this_.get());

    object_store.dispose(uid);

    LOG(&quot;Disposed array [%p]&quot;, this_.get());
  }
};

/**
 * A representation of an array with access methods.
 *
 * @class gdal.MDArray
 */
NAN_METHOD(MDArray::New) {
  Nan::HandleScope scope;

  if (!info.IsConstructCall()) {
    Nan::ThrowError(&quot;Cannot call constructor as function, you need to use &#x27;new&#x27; keyword&quot;);
    return;
  }

  if (info.Length() == 2 &amp;&amp; info[0]-&gt;IsExternal() &amp;&amp; info[1]-&gt;IsObject()) {
    Local&lt;External&gt; ext = info[0].As&lt;External&gt;();
    void *ptr = ext-&gt;Value();
    MDArray *f = static_cast&lt;MDArray *&gt;(ptr);
    f-&gt;Wrap(info.This());

    Local&lt;Value&gt; dims = ArrayDimensions::New(info.This(), info[1]);
    Nan::SetPrivate(info.This(), Nan::New(&quot;dims_&quot;).ToLocalChecked(), dims);
    Local&lt;Value&gt; attrs = ArrayAttributes::New(info.This(), info[1]);
    Nan::SetPrivate(info.This(), Nan::New(&quot;attrs_&quot;).ToLocalChecked(), attrs);

    info.GetReturnValue().Set(info.This());
    return;
  } else {
    Nan::ThrowError(&quot;Cannot create MDArray directly. Create with dataset instead.&quot;);
    return;
  }

  info.GetReturnValue().Set(info.This());
}

Local&lt;Value&gt; MDArray::New(std::shared_ptr&lt;GDALMDArray&gt; raw, GDALDataset *parent_ds) {
  Nan::EscapableHandleScope scope;

  if (!raw) { return scope.Escape(Nan::Null()); }
  if (object_store.has(raw)) { return scope.Escape(object_store.get(raw)); }

  MDArray *wrapped = new MDArray(raw);

  // add reference to datasource so datasource doesnt get GC&#x27;ed while group is
  // alive
  Local&lt;Object&gt; ds, group;
  if (object_store.has(parent_ds)) {
    ds = object_store.get(parent_ds);
  } else {
    LOG(&quot;MDArray&#x27;s parent dataset disappeared from cache (array = %p, dataset = %p)&quot;, raw.get(), parent_ds);
    Nan::ThrowError(&quot;MDArray&#x27;s parent dataset disappeared from cache&quot;);
    return scope.Escape(Nan::Undefined());
  }

  Local&lt;Value&gt; ext = Nan::New&lt;External&gt;(wrapped);
  Local&lt;Value&gt; argv[] = {ext, ds};
  Local&lt;Object&gt; obj =
    Nan::NewInstance(Nan::GetFunction(Nan::New(MDArray::constructor)).ToLocalChecked(), 2, argv).ToLocalChecked();

  size_t dim = raw-&gt;GetDimensionCount();

  Dataset *unwrapped_ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(ds);
  long parent_uid = unwrapped_ds-&gt;uid;

  wrapped-&gt;uid = object_store.add(raw, wrapped-&gt;persistent(), parent_uid);
  wrapped-&gt;parent_ds = parent_ds;
  wrapped-&gt;parent_uid = parent_uid;
  wrapped-&gt;dimensions = dim;

  Nan::SetPrivate(obj, Nan::New(&quot;ds_&quot;).ToLocalChecked(), ds);

  return scope.Escape(obj);
}

NAN_METHOD(MDArray::toString) {
  Nan::HandleScope scope;
  info.GetReturnValue().Set(Nan::New(&quot;MDArray&quot;).ToLocalChecked());
}

/**
 * @typedef MDArrayOptions { origin: number[], span: number[], stride?: number[], data_type?: string, data?: TypedArray, _offset?: number }
 */

/* Find the lowest possible element index for the given spans and strides */
static inline int
findLowest(int dimensions, std::shared_ptr&lt;size_t&gt; span, std::shared_ptr&lt;GPtrDiff_t&gt; stride, GPtrDiff_t offset) {
  GPtrDiff_t dimStride = 1;
  GPtrDiff_t lowest = 0;
  for (int dim = 0; dim &lt; dimensions; dim++) {
    if (stride != nullptr) {
      // strides are given
      dimStride = stride.get()[dim];
    } else {
      // default strides: 1 on the first dimension -or- (size of the current dimensions) x (stride of the previous dimension)
      if (dim &gt; 0) dimStride = dimStride * span.get()[dim - 1];
    }

    // Lowest address element on this dimension
    size_t element;
    if (dimStride &lt; 0)
      element = span.get()[dim] - 1;
    else
      element = 0;

    lowest += element * dimStride;
  }

  return offset + lowest;
}

/* Find the highest possible element index for the given spans and strides */
static inline int
findHighest(int dimensions, std::shared_ptr&lt;size_t&gt; span, std::shared_ptr&lt;GPtrDiff_t&gt; stride, GPtrDiff_t offset) {
  GPtrDiff_t dimStride = 1;
  GPtrDiff_t highest = 0;
  for (int dim = 0; dim &lt; dimensions; dim++) {
    if (stride != nullptr) {
      // strides are given
      dimStride = stride.get()[dim];
    } else {
      // default strides: 1 on the first dimension -or- (size of the current dimensions) x (stride of the previous dimension)
      if (dim &gt; 0) dimStride = dimStride * span.get()[dim - 1];
    }

    // Highest address element on this dimension
    size_t element;
    if (dimStride &gt; 0)
      element = span.get()[dim] - 1;
    else
      element = 0;

    highest += element * dimStride;
  }

  return offset + highest;
}

/**
 * Read data from the MDArray
 * 
 * This will extract the context of a (hyper-)rectangle from the array into a buffer.
 * If the buffer can be passed as an argument or it can be allocated by the function.
 * Generalized n-dimensional strides are supported.
 * 
 * Although this method can be used in its raw form, it works best when used with the ndarray plugin.
 * 
 * @method read
 * @throws Error
 * @param {MDArrayOptions} options
 * @param {number[]} options.origin An array of the starting indices
 * @param {number[]} options.span An array specifying the number of elements to read in each dimension
 * @param {number[]} [options.stride] An array of strides for the output array, mandatory if the array is specified
 * @param {string} [options.data_type] See {{#crossLink &quot;Constants (GDT)&quot;}}GDT constants{{/crossLink}}.
 * @param {TypedArray} [options.data] The TypedArray (https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView#Typed_array_subclasses) to put the data in. A new array is created if not given.
 * @return {TypedArray}
 */

/**
 * Read data from the MDArray
 * {{{async}}}
 * 
 * This will extract the context of a (hyper-)rectangle from the array into a buffer.
 * If the buffer can be passed as an argument or it can be allocated by the function.
 * Generalized n-dimensional strides are supported.
 * 
 * Although this method can be used in its raw form, it works best when used with the ndarray plugin.
 * 
 * @method readAsync
 * @throws Error
 * @param {MDArrayOptions} options
 * @param {number[]} options.origin An array of the starting indices
 * @param {number[]} options.span An array specifying the number of elements to read in each dimension
 * @param {number[]} [options.stride] An array of strides for the output array, mandatory if the array is specified
 * @param {string} [options.data_type] See {{#crossLink &quot;Constants (GDT)&quot;}}GDT constants{{/crossLink}}.
 * @param {TypedArray} [options.data] The TypedArray (https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView#Typed_array_subclasses) to put the data in. A new array is created if not given.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 * @param {callback&lt;TypedArray&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;TypedArray&gt;} A TypedArray (https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView#Typed_array_subclasses) of values.
 */
GDAL_ASYNCABLE_DEFINE(MDArray::read) {
  Nan::HandleScope scope;

  NODE_UNWRAP_CHECK(MDArray, info.This(), self);

  Local&lt;Object&gt; options;
  Local&lt;Array&gt; origin, span, stride;
  std::string type_name;
  GDALDataType type = GDT_Byte;
  GPtrDiff_t offset = 0;

  NODE_ARG_OBJECT(0, &quot;options&quot;, options);
  NODE_ARRAY_FROM_OBJ(options, &quot;origin&quot;, origin);
  NODE_ARRAY_FROM_OBJ(options, &quot;span&quot;, span);
  NODE_ARRAY_FROM_OBJ_OPT(options, &quot;stride&quot;, stride);
  NODE_STR_FROM_OBJ_OPT(options, &quot;data_type&quot;, type_name);
  NODE_INT64_FROM_OBJ_OPT(options, &quot;_offset&quot;, offset);
  if (!type_name.empty()) { type = GDALGetDataTypeByName(type_name.c_str()); }

  std::shared_ptr&lt;GUInt64&gt; gdal_origin;
  std::shared_ptr&lt;size_t&gt; gdal_span;
  std::shared_ptr&lt;GPtrDiff_t&gt; gdal_stride;
  try {
    gdal_origin = NumberArrayToSharedPtr&lt;int64_t, GUInt64&gt;(origin, self-&gt;dimensions);
    gdal_span = NumberArrayToSharedPtr&lt;int64_t, size_t&gt;(span, self-&gt;dimensions);
    gdal_stride = NumberArrayToSharedPtr&lt;int64_t, GPtrDiff_t&gt;(stride, self-&gt;dimensions);
  } catch (const char *e) {
    Nan::ThrowError(e);
    return;
  }
  GPtrDiff_t highest = findHighest(self-&gt;dimensions, gdal_span, gdal_stride, offset);
  GPtrDiff_t lowest = findLowest(self-&gt;dimensions, gdal_span, gdal_stride, offset);
  size_t length = (highest - (lowest &lt; 0 ? lowest : 0)) + 1;

  Local&lt;String&gt; sym = Nan::New(&quot;data&quot;).ToLocalChecked();
  Local&lt;Value&gt; data;
  Local&lt;Object&gt; array;
  if (Nan::HasOwnProperty(options, sym).FromMaybe(false)) {
    data = Nan::Get(options, sym).ToLocalChecked();
    if (!data-&gt;IsUndefined() &amp;&amp; !data-&gt;IsNull()) {
      array = data.As&lt;Object&gt;();
      type = node_gdal::TypedArray::Identify(array);
      if (type == GDT_Unknown) {
        Nan::ThrowError(&quot;Invalid array&quot;);
        return;
      }
    }
  }

  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, self, gdal_mdarray);

  // create array if no array was passed
  if (data.IsEmpty()) {
    if (type_name.empty()) {
      auto exType = gdal_mdarray-&gt;GetDataType();
      if (exType.GetClass() != GEDTC_NUMERIC) {
        Nan::ThrowTypeError(&quot;Reading of extended data types is not supported yet&quot;);
        return;
      }
      type = exType.GetNumericDataType();
    }
    data = node_gdal::TypedArray::New(type, length);
    if (data.IsEmpty() || !data-&gt;IsObject()) {
      Nan::ThrowError(&quot;Failed to allocate array&quot;);
      return; // TypedArray::New threw an error
    }
    array = data.As&lt;Object&gt;();
  }

  if (lowest &lt; 0) {
    Nan::ThrowRangeError(&quot;Will have to read before the start of the array&quot;);
    return;
  }

  void *buffer = node_gdal::TypedArray::Validate(array, type, length);
  if (!buffer) {
    Nan::ThrowError(&quot;Failed to allocate array&quot;);
    return; // TypedArray::Validate threw an error
  }

  GDALAsyncableJob&lt;bool&gt; job(self-&gt;parent_uid);
  job.persist(&quot;array&quot;, array);

  job.main =
    [buffer, gdal_mdarray, gdal_origin, gdal_span, gdal_stride, type, length, offset](const GDALExecutionProgress &amp;) {
      int bytes_per_pixel = GDALGetDataTypeSize(type) / 8;
      CPLErrorReset();
      GDALExtendedDataType gdal_type = GDALExtendedDataType::Create(type);
      bool success = gdal_mdarray-&gt;Read(
        gdal_origin.get(),
        gdal_span.get(),
        nullptr,
        gdal_stride.get(),
        gdal_type,
        (void *)((uint8_t *)buffer + offset * bytes_per_pixel),
        buffer,
        length * bytes_per_pixel);
      if (!success) { throw CPLGetLastErrorMsg(); }
      return success;
    };
  job.rval = [](bool success, GetFromPersistentFunc getter) { return getter(&quot;array&quot;); };
  job.run(info, async, 1);
}

/**
 * Get a partial view of the MDArray
 * 
 * The slice expression uses the same syntax as NumPy basic slicing and indexing. See (https://www.numpy.org/devdocs/reference/arrays.indexing.html#basic-slicing-and-indexing). Or it can use field access by name. See (https://www.numpy.org/devdocs/reference/arrays.indexing.html#field-access).
 *
 * @method getView
 * @throws Error
 * @param {string} view
 * @return {gdal.MDArray}
 */
NAN_METHOD(MDArray::getView) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, array, raw);

  std::string viewExpr;
  NODE_ARG_STR(0, &quot;view&quot;, viewExpr);
  GDAL_LOCK_PARENT(array);
  CPLErrorReset();
  std::shared_ptr&lt;GDALMDArray&gt; view = raw-&gt;GetView(viewExpr);
  if (view == nullptr) {
    Nan::ThrowError(CPLGetLastErrorMsg());
    return;
  }
  Local&lt;Value&gt; obj = New(view, array-&gt;parent_ds);
  info.GetReturnValue().Set(obj);
}

/**
 * Return an array that is a mask for the current array.
 * 
 * This array will be of type Byte, with values set to 0 to indicate invalid pixels of the current array, and values set to 1 to indicate valid pixels.
 * 
 * The generic implementation honours the NoDataValue, as well as various netCDF CF attributes: missing_value, _FillValue, valid_min, valid_max and valid_range.
 *
 * @method getMask
 * @throws Error
 * @return {gdal.MDArray}
 */
NAN_METHOD(MDArray::getMask) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, array, raw);

  GDAL_LOCK_PARENT(array);
  CPLErrorReset();
  std::shared_ptr&lt;GDALMDArray&gt; mask = raw-&gt;GetMask(NULL);
  if (mask == nullptr) {
    Nan::ThrowError(CPLGetLastErrorMsg());
    return;
  }
  Local&lt;Value&gt; obj = New(mask, array-&gt;parent_ds);
  info.GetReturnValue().Set(obj);
}

/**
 * Return a view of this array as a gdal.Dataset (ie 2D)
 *
 * In the case of &gt; 2D arrays, additional dimensions will be represented as raster bands.
 *
 * @method asDataset
 * @param {number|string} x dimension to be used as X axis
 * @param {number|string} y dimension to be used as Y axis
 * @throws Error
 * @return {gdal.Dataset}
 */
NAN_METHOD(MDArray::asDataset) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, array, raw);

  int x = -1, y = -1;
  std::string dim;
  NODE_ARG_STR_INT(0, &quot;x&quot;, dim, x, isXString);
  if (isXString) x = ArrayDimensions::__getIdx(raw, dim);
  NODE_ARG_STR_INT(1, &quot;y&quot;, dim, y, isYString);
  if (isYString) y = ArrayDimensions::__getIdx(raw, dim);

  GDAL_LOCK_PARENT(array);
  CPLErrorReset();
  GDALDataset *ds = raw-&gt;AsClassicDataset(x, y);
  if (ds == nullptr) {
    Nan::ThrowError(CPLGetLastErrorMsg());
    return;
  }
  Local&lt;Value&gt; obj = Dataset::New(ds, array-&gt;parent_ds);
  info.GetReturnValue().Set(obj);
}

/**
 * Spatial reference associated with MDArray
 *
 * @throws Error
 * @attribute srs
 * @type {gdal.SpatialReference}
 */
NAN_GETTER(MDArray::srsGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, array, raw);
  GDAL_LOCK_PARENT(array);
  std::shared_ptr&lt;OGRSpatialReference&gt; srs = raw-&gt;GetSpatialRef();
  if (srs == nullptr) {
    info.GetReturnValue().Set(Nan::Null());
    return;
  }

  info.GetReturnValue().Set(SpatialReference::New(srs.get(), false));
}

/**
 * Raster value offset.
 *
 * @attribute offset
 * @type {number}
 */
NAN_GETTER(MDArray::offsetGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  bool hasOffset = false;
  GDAL_LOCK_PARENT(array);
  double result = array-&gt;this_-&gt;GetOffset(&amp;hasOffset);
  if (hasOffset)
    info.GetReturnValue().Set(Nan::New&lt;Number&gt;(result));
  else
    info.GetReturnValue().Set(Nan::New&lt;Number&gt;(0));
}

/**
 * Raster value scale.
 *
 * @attribute scale
 * @type {number}
 */
NAN_GETTER(MDArray::scaleGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  bool hasScale = false;
  GDAL_LOCK_PARENT(array);
  double result = array-&gt;this_-&gt;GetScale(&amp;hasScale);
  if (hasScale)
    info.GetReturnValue().Set(Nan::New&lt;Number&gt;(result));
  else
    info.GetReturnValue().Set(Nan::New&lt;Number&gt;(1));
}

/**
 * No data value for this array.
 *
 * @attribute noDataValue
 * @type {number|null}
 */
NAN_GETTER(MDArray::noDataValueGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  bool hasNoData = false;
  GDAL_LOCK_PARENT(array);
  double result = array-&gt;this_-&gt;GetNoDataValueAsDouble(&amp;hasNoData);

  if (hasNoData &amp;&amp; !std::isnan(result)) {
    info.GetReturnValue().Set(Nan::New&lt;Number&gt;(result));
    return;
  } else {
    info.GetReturnValue().Set(Nan::Null());
    return;
  }
}

/**
 * Raster unit type (name for the units of this raster&#x27;s values).
 * For instance, it might be &#x60;&quot;m&quot;&#x60; for an elevation model in meters,
 * or &#x60;&quot;ft&quot;&#x60; for feet. If no units are available, a value of &#x60;&quot;&quot;&#x60;
 * will be returned.
 *
 * @attribute unitType
 * @type {string}
 */
NAN_GETTER(MDArray::unitTypeGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_LOCK_PARENT(array);
  std::string unit = array-&gt;this_-&gt;GetUnit();
  info.GetReturnValue().Set(SafeString::New(unit.c_str()));
}

/**
 * @readOnly
 * @attribute dataType
 * @type {string}
 */
NAN_GETTER(MDArray::typeGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, array, raw);
  GDAL_LOCK_PARENT(array);
  GDALExtendedDataType type = raw-&gt;GetDataType();
  const char *r;
  switch (type.GetClass()) {
    case GEDTC_NUMERIC: r = GDALGetDataTypeName(type.GetNumericDataType()); break;
    case GEDTC_STRING: r = &quot;String&quot;; break;
    case GEDTC_COMPOUND: r = &quot;Compound&quot;; break;
    default: Nan::ThrowError(&quot;Invalid attribute type&quot;); return;
  }
  info.GetReturnValue().Set(SafeString::New(r));
}

/**
 * @readOnly
 * @attribute dimensions
 * @type {gdal.GroupDimensions}
 */
NAN_GETTER(MDArray::dimensionsGetter) {
  Nan::HandleScope scope;
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;dims_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute attributes
 * @type {gdal.ArrayAttributes}
 */
NAN_GETTER(MDArray::attributesGetter) {
  Nan::HandleScope scope;
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;attrs_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute description
 * @type {string}
 */
NAN_GETTER(MDArray::descriptionGetter) {
  Nan::HandleScope scope;
  NODE_UNWRAP_CHECK(MDArray, info.This(), array);
  GDAL_RAW_CHECK(std::shared_ptr&lt;GDALMDArray&gt;, array, raw);
  GDAL_LOCK_PARENT(array);
  std::string description = raw-&gt;GetFullName();
  info.GetReturnValue().Set(SafeString::New(description.c_str()));
}

/**
 * The flattened length of the array
 * 
 * @readOnly
 * @attribute length
 * @type {number}
 */
NODE_WRAPPED_GETTER_WITH_RESULT_LOCKED(MDArray, lengthGetter, Number, GetTotalElementsCount);

NAN_GETTER(MDArray::uidGetter) {
  Nan::HandleScope scope;
  MDArray *ds = Nan::ObjectWrap::Unwrap&lt;MDArray&gt;(info.This());
  info.GetReturnValue().Set(Nan::New((int)ds-&gt;uid));
}

#endif

} // namespace node_gdal

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
