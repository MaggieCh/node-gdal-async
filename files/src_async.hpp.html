<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/async.hpp - node-gdal-async</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-async" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-async">
            node-gdal-async
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>3.3.3</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DIM)", "classes/Constants (DIR)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.ArrayAttributes", "classes/gdal.ArrayDimensions", "classes/gdal.Attribute", "classes/gdal.CircularString", "classes/gdal.CompoundCurve", "classes/gdal.CompoundCurveCurves", "classes/gdal.config", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Dimension", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Group", "classes/gdal.GroupArrays", "classes/gdal.GroupAttributes", "classes/gdal.GroupDimensions", "classes/gdal.GroupGroups", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MDArray", "classes/gdal.MultiCurve", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.SimpleCurve", "classes/gdal.SpatialReference", "classes/vsimem
Operations on in-memory /vsimem/ files"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DIM).html">Constants (DIM)</a></li>
                <li><a href="../classes/Constants (DIR).html">Constants (DIR)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.ArrayAttributes.html">gdal.ArrayAttributes</a></li>
                <li><a href="../classes/gdal.ArrayDimensions.html">gdal.ArrayDimensions</a></li>
                <li><a href="../classes/gdal.Attribute.html">gdal.Attribute</a></li>
                <li><a href="../classes/gdal.CircularString.html">gdal.CircularString</a></li>
                <li><a href="../classes/gdal.CompoundCurve.html">gdal.CompoundCurve</a></li>
                <li><a href="../classes/gdal.CompoundCurveCurves.html">gdal.CompoundCurveCurves</a></li>
                <li><a href="../classes/gdal.config.html">gdal.config</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Dimension.html">gdal.Dimension</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Group.html">gdal.Group</a></li>
                <li><a href="../classes/gdal.GroupArrays.html">gdal.GroupArrays</a></li>
                <li><a href="../classes/gdal.GroupAttributes.html">gdal.GroupAttributes</a></li>
                <li><a href="../classes/gdal.GroupDimensions.html">gdal.GroupDimensions</a></li>
                <li><a href="../classes/gdal.GroupGroups.html">gdal.GroupGroups</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MDArray.html">gdal.MDArray</a></li>
                <li><a href="../classes/gdal.MultiCurve.html">gdal.MultiCurve</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.SimpleCurve.html">gdal.SimpleCurve</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
                <li><a href="../classes/vsimem
Operations on in-memory /vsimem/ files.html">vsimem
Operations on in-memory /vsimem/ files</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/async.hpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
#ifndef __NODE_GDAL_ASYNC_WORKER_H__
#define __NODE_GDAL_ASYNC_WORKER_H__

#include &lt;functional&gt;
#include &lt;chrono&gt;
#include &quot;nan-wrapper.h&quot;
#include &quot;gdal_common.hpp&quot;

namespace node_gdal {

// This generates method definitions for 2 methods: sync and async version and a hidden common block
#define GDAL_ASYNCABLE_DEFINE(method)                                                                                  \
  NAN_METHOD(method) {                                                                                                 \
    method##_do(info, false);                                                                                          \
  }                                                                                                                    \
  NAN_METHOD(method##Async) {                                                                                          \
    method##_do(info, true);                                                                                           \
  }                                                                                                                    \
  void method##_do(const Nan::FunctionCallbackInfo&lt;v8::Value&gt; &amp;info, bool async)

// This generates getter definitions for 2 getters: sync and async version and a hidden common block
#define GDAL_ASYNCABLE_GETTER_DEFINE(method)                                                                           \
  NAN_GETTER(method) {                                                                                                 \
    method##_do(property, info, false);                                                                                \
  }                                                                                                                    \
  NAN_GETTER(method##Async) {                                                                                          \
    method##_do(property, info, true);                                                                                 \
  }                                                                                                                    \
  Nan::NAN_GETTER_RETURN_TYPE method##_do(v8::Local&lt;v8::String&gt; property, Nan::NAN_GETTER_ARGS_TYPE info, bool async)

// This generates method declarations for 2 methods: sync and async version and a hidden common block
#define GDAL_ASYNCABLE_DECLARE(method)                                                                                 \
  static NAN_METHOD(method);                                                                                           \
  static NAN_METHOD(method##Async);                                                                                    \
  static void method##_do(const Nan::FunctionCallbackInfo&lt;v8::Value&gt; &amp;info, bool async)

// This generates getter declarations for 2 getters: sync and async version and a hidden common block
#define GDAL_ASYNCABLE_GETTER_DECLARE(method)                                                                          \
  static NAN_GETTER(method);                                                                                           \
  static NAN_GETTER(method##Async);                                                                                    \
  static Nan::NAN_GETTER_RETURN_TYPE method##_do(                                                                      \
    v8::Local&lt;v8::String&gt; property, Nan::NAN_GETTER_ARGS_TYPE info, bool async)

#define GDAL_ASYNCABLE_GLOBAL(method)                                                                                  \
  NAN_METHOD(method);                                                                                                  \
  NAN_METHOD(method##Async);                                                                                           \
  void method##_do(const Nan::FunctionCallbackInfo&lt;v8::Value&gt; &amp;info, bool async)

#define GDAL_ASYNCABLE_TEMPLATE(method)                                                                                \
  static NAN_METHOD(method) {                                                                                          \
    method##_do(info, false);                                                                                          \
  }                                                                                                                    \
  static NAN_METHOD(method##Async) {                                                                                   \
    method##_do(info, true);                                                                                           \
  }                                                                                                                    \
  static void method##_do(const Nan::FunctionCallbackInfo&lt;v8::Value&gt; &amp;info, bool async)

#define GDAL_ISASYNC async

#define THROW_OR_REJECT(msg)                                                                                           \
  if (async) {                                                                                                         \
    auto context = info.GetIsolate()-&gt;GetCurrentContext();                                                             \
    auto resolver = v8::Promise::Resolver::New(context).ToLocalChecked();                                              \
    resolver-&gt;Reject(context, Nan::Error(msg)).FromJust();                                                             \
    info.GetReturnValue().Set(resolver-&gt;GetPromise());                                                                 \
  } else                                                                                                               \
    Nan::ThrowError(msg);

// Handle locking (used only for sync methods)
#define GDAL_LOCK_PARENT(p)                                                                                            \
  AsyncGuard lock;                                                                                                     \
  try {                                                                                                                \
    lock.acquire((p)-&gt;parent_uid);                                                                                     \
  } catch (const char *err) {                                                                                          \
    Nan::ThrowError(err);                                                                                              \
    return;                                                                                                            \
  }

static const char eventLoopWarning[] =
  &quot;Synchronous method called while an asynchronous operation is running in the background, check node_modules/gdal-async/ASYNCIO.md, event loop blocked for &quot;;
// These constructors throw
// Only one use case never throws: on the main thread
// and after checking that the Dataset is alive
class AsyncGuard {
    public:
  inline AsyncGuard() : lock(nullptr), locks(nullptr) {
  }
  inline AsyncGuard(long uid) : locks(nullptr) {
    lock = object_store.lockDataset(uid);
  }
  inline AsyncGuard(vector&lt;long&gt; uids) : lock(nullptr), locks(nullptr) {
    if (uids.size() == 1)
      lock = object_store.lockDataset(uids[0]);
    else
      locks = make_shared&lt;vector&lt;AsyncLock&gt;&gt;(object_store.lockDatasets(uids));
  }
  inline AsyncGuard(vector&lt;long&gt; uids, bool warning) : lock(nullptr), locks(nullptr) {
    if (uids.size() == 1) {
      if (uids[0] == 0) return;
      lock = warning ? object_store.tryLockDataset(uids[0]) : object_store.lockDataset(uids[0]);
      if (lock == nullptr) {
        auto start = std::chrono::high_resolution_clock::now();
        fprintf(stderr, eventLoopWarning);
        lock = object_store.lockDataset(uids[0]);
        auto elapsed = std::chrono::high_resolution_clock::now() - start;
        fprintf(
          stderr,
          &quot;%ld µs\n&quot;,
          static_cast&lt;long&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count()));
      }
    } else {
      locks = warning ? make_shared&lt;vector&lt;AsyncLock&gt;&gt;(object_store.tryLockDatasets(uids))
                      : make_shared&lt;vector&lt;AsyncLock&gt;&gt;(object_store.lockDatasets(uids));
      if (locks-&gt;size() == 0) {
        auto start = std::chrono::high_resolution_clock::now();
        fprintf(stderr, eventLoopWarning);
        auto elapsed = std::chrono::high_resolution_clock::now() - start;
        fprintf(
          stderr,
          &quot;%ld µs\n&quot;,
          static_cast&lt;long&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count()));
      }
    }
  }
  inline void acquire(long uid) {
    if (lock != nullptr) throw &quot;Trying to acquire multiple locks&quot;;
    lock = object_store.lockDataset(uid);
  }
  inline ~AsyncGuard() {
    if (lock != nullptr) object_store.unlockDataset(lock);
    if (locks != nullptr) object_store.unlockDatasets(*locks);
  }

    private:
  AsyncLock lock;
  shared_ptr&lt;vector&lt;AsyncLock&gt;&gt; locks;
};

// Node.js NAN null initializes and trivially copies objects of this class without asking permission
struct GDALProgressInfo {
  double complete;
  const char *message;

  GDALProgressInfo(const GDALProgressInfo &amp;o);
  GDALProgressInfo(double, const char *);
  GDALProgressInfo();
};

class GDALSyncExecutionProgress {
  Nan::Callback *progress_callback;

  GDALSyncExecutionProgress() = delete;

    public:
  GDALSyncExecutionProgress(Nan::Callback *);
  ~GDALSyncExecutionProgress();
  void Send(GDALProgressInfo *) const;
};

typedef std::function&lt;v8::Local&lt;v8::Value&gt;(const char *)&gt; GetFromPersistentFunc;
typedef Nan::AsyncProgressWorkerBase&lt;GDALProgressInfo&gt; GDALAsyncProgressWorker;
typedef GDALAsyncProgressWorker::ExecutionProgress GDALAsyncExecutionProgress;

// This an ExecutionContext that works both with Node.js&#x27; NAN ExecutionProgress when in async mode
// and with GDALSyncExecutionContext when in sync mode
class GDALExecutionProgress {
  // Only one of these is active at any given moment
  const GDALAsyncExecutionProgress *async;
  const GDALSyncExecutionProgress *sync;

  GDALExecutionProgress() = delete;

    public:
  GDALExecutionProgress(const GDALAsyncExecutionProgress *);
  GDALExecutionProgress(const GDALSyncExecutionProgress *);
  ~GDALExecutionProgress();
  void Send(GDALProgressInfo *info) const;
};

/**
 * @typedef ProgressOptions { progress_cb: ProgressCb }
 */

/**
 * @typedef ProgressCb ( complete: number, msg: string ) =&gt; void
 */

// This is the progress callback trampoline
// It can be invoked both in the main thread (in sync mode) or in auxillary thread (in async mode)
// It is essentially a gateway between the GDAL world and Node.js/V8 world
int ProgressTrampoline(double dfComplete, const char *pszMessage, void *pProgressArg);

//
// This is the common class for handling async operations
// It has two subclasses: GDALCallbackWorker and GDALPromiseWorker
// They are meant to be used by GDALAsyncableJob defined below
//
// It takes the lambdas as input
// GDALType is the type of the object that will be carried from
// the aux thread to the main thread
//
// JS-visible object creation is possible only in the main thread while
// ths JS world is not running
//
template &lt;class GDALType&gt; class GDALAsyncWorker : public GDALAsyncProgressWorker {
    public:
  typedef std::function&lt;GDALType(const GDALExecutionProgress &amp;)&gt; GDALMainFunc;
  typedef std::function&lt;v8::Local&lt;v8::Value&gt;(const GDALType, const GetFromPersistentFunc &amp;)&gt; GDALRValFunc;

    private:
  Nan::Callback *progressCallback;
  const GDALMainFunc doit;
  const GDALRValFunc rval;
  const std::vector&lt;long&gt; ds_uids;
  GDALType raw;

    public:
  explicit GDALAsyncWorker(
    Nan::Callback *resultCallback,
    Nan::Callback *progressCallback,
    const GDALMainFunc &amp;doit,
    const GDALRValFunc &amp;rval,
    const std::map&lt;std::string, v8::Local&lt;v8::Object&gt;&gt; &amp;objects,
    const std::vector&lt;long&gt; &amp;ds_uids);

  ~GDALAsyncWorker();

  void Execute(const ExecutionProgress &amp;progress);
  Local&lt;Value&gt; ProduceRVal();
  void HandleProgressCallback(const GDALProgressInfo *data, size_t count);
};

template &lt;class GDALType&gt;
GDALAsyncWorker&lt;GDALType&gt;::GDALAsyncWorker(
  Nan::Callback *resultCallback,
  Nan::Callback *progressCallback,
  const GDALMainFunc &amp;doit,
  const GDALRValFunc &amp;rval,
  const std::map&lt;std::string, v8::Local&lt;v8::Object&gt;&gt; &amp;objects,
  const std::vector&lt;long&gt; &amp;ds_uids)
  : GDALAsyncProgressWorker(resultCallback, &quot;node-gdal:GDALAsyncWorker&quot;),
    progressCallback(progressCallback),
    // These members are not references! These functions must be copied
    // as they will be executed in async context!
    doit(doit),
    rval(rval),
    ds_uids(ds_uids) {
  // Main thread with the JS world is not running
  // Get persistent handles
  for (auto i = objects.begin(); i != objects.end(); i++) SaveToPersistent(i-&gt;first.c_str(), i-&gt;second);
  for (auto i = ds_uids.begin(); i != ds_uids.end(); i++)
    if (*i != 0) SaveToPersistent((&quot;ds&quot; + std::to_string(*i)).c_str(), object_store.get&lt;GDALDataset *&gt;(*i));
}

template &lt;class GDALType&gt; Local&lt;Value&gt; GDALAsyncWorker&lt;GDALType&gt;::ProduceRVal() {
  return rval(raw, [this](const char *key) { return this-&gt;GetFromPersistent(key); });
}

template &lt;class GDALType&gt; void GDALAsyncWorker&lt;GDALType&gt;::Execute(const ExecutionProgress &amp;progress) {
  // Aux thread with the JS world running
  // V8 objects are not acessible here
  try {
    GDALExecutionProgress executionProgress(&amp;progress);
    AsyncGuard lock(ds_uids);
    raw = doit(executionProgress);
  } catch (const char *err) { this-&gt;SetErrorMessage(err); }
}

template &lt;class GDALType&gt; GDALAsyncWorker&lt;GDALType&gt;::~GDALAsyncWorker() {
  if (progressCallback != nullptr) delete progressCallback;
}

template &lt;class GDALType&gt;
void GDALAsyncWorker&lt;GDALType&gt;::HandleProgressCallback(const GDALProgressInfo *data, size_t count) {
  if (progressCallback == nullptr) return;
  // Back to the main thread with the JS world not running
  Nan::HandleScope scope;
  // A mutex-protected pop in the calling function (in Node.js NAN) can sometimes produce a spurious call
  // with no data, handle gracefully this case -&gt; no need to call JS if there is not data to deliver
  if (data == nullptr || count == 0) return;
  // Receiving more than one callback invocation at the same time is also possible
  // Send only the last one to JS
  const GDALProgressInfo *to_send = data + (count - 1);
  if (data != nullptr &amp;&amp; count &gt; 0) {
    v8::Local&lt;v8::Value&gt; argv[] = {Nan::New&lt;Number&gt;(to_send-&gt;complete), SafeString::New(to_send-&gt;message)};
    progressCallback-&gt;Call(2, argv, this-&gt;async_resource);
  }
}

// This async worker calls a callback
template &lt;class GDALType&gt; class GDALCallbackWorker : public GDALAsyncWorker&lt;GDALType&gt; {
    public:
  using GDALAsyncWorker&lt;GDALType&gt;::GDALAsyncWorker;
  void HandleOKCallback();
  void HandleErrorCallback();
};

template &lt;class GDALType&gt; void GDALCallbackWorker&lt;GDALType&gt;::HandleOKCallback() {
  // Back to the main thread with the JS world not running
  Nan::HandleScope scope;

  // rval is the user function that will create the returned value
  // we give it a lambda that can access the persistent storage created for this operation
  // It uses our HandleScope so it can return a Local without escaping
  v8::Local&lt;v8::Value&gt; argv[] = {Nan::Null(), this-&gt;ProduceRVal()};
  this-&gt;callback-&gt;Call(2, argv, this-&gt;async_resource);
}

template &lt;class GDALType&gt; void GDALCallbackWorker&lt;GDALType&gt;::HandleErrorCallback() {
  // Back to the main thread with the JS world not running
  Nan::HandleScope scope;
  v8::Local&lt;v8::Value&gt; argv[] = {Nan::Error(this-&gt;ErrorMessage())};
  this-&gt;callback-&gt;Call(1, argv, this-&gt;async_resource);
}

// This async worker returns a Promise
template &lt;class GDALType&gt; class GDALPromiseWorker : public GDALAsyncWorker&lt;GDALType&gt; {
    public:
  typedef typename GDALAsyncWorker&lt;GDALType&gt;::GDALMainFunc GDALMainFunc;
  typedef typename GDALAsyncWorker&lt;GDALType&gt;::GDALRValFunc GDALRValFunc;

    private:
  Nan::Persistent&lt;v8::Promise::Resolver&gt; *resolver_handle;
  Nan::Persistent&lt;v8::Context&gt; *context_handle;

    public:
  explicit GDALPromiseWorker(
    Nan::NAN_GETTER_ARGS_TYPE info,
    const GDALMainFunc &amp;doit,
    const GDALRValFunc &amp;rval,
    const std::map&lt;std::string, v8::Local&lt;v8::Object&gt;&gt; &amp;objects,
    const std::vector&lt;long&gt; &amp;ds_uids);

  ~GDALPromiseWorker();

  void HandleOKCallback();
  void HandleErrorCallback();
  inline Local&lt;Value&gt; Promise() {
    return Nan::New(*resolver_handle)-&gt;GetPromise();
  };
};

template &lt;class GDALType&gt;
GDALPromiseWorker&lt;GDALType&gt;::GDALPromiseWorker(
  Nan::NAN_GETTER_ARGS_TYPE info,
  const GDALMainFunc &amp;doit,
  const GDALRValFunc &amp;rval,
  const std::map&lt;std::string, v8::Local&lt;v8::Object&gt;&gt; &amp;objects,
  const std::vector&lt;long&gt; &amp;ds_uids)
  : GDALAsyncWorker&lt;GDALType&gt;(nullptr, nullptr, doit, rval, objects, ds_uids) {
  auto context = info.GetIsolate()-&gt;GetCurrentContext();
  context_handle = new Nan::Persistent&lt;v8::Context&gt;(context);
  auto resolver = v8::Promise::Resolver::New(context).ToLocalChecked();
  resolver_handle = new Nan::Persistent&lt;v8::Promise::Resolver&gt;(resolver);
}

template &lt;class GDALType&gt; void GDALPromiseWorker&lt;GDALType&gt;::HandleOKCallback() {
  Nan::HandleScope scope;
  v8::Local&lt;v8::Context&gt; context = Nan::New(*context_handle);
  v8::Local&lt;v8::Promise::Resolver&gt; resolver = Nan::New(*resolver_handle);
  resolver-&gt;Resolve(context, this-&gt;ProduceRVal()).FromJust();
}

template &lt;class GDALType&gt; void GDALPromiseWorker&lt;GDALType&gt;::HandleErrorCallback() {
  Nan::HandleScope scope;
  v8::Local&lt;v8::Context&gt; context = Nan::New(*context_handle);
  v8::Local&lt;v8::Promise::Resolver&gt; resolver = Nan::New(*resolver_handle);
  resolver-&gt;Reject(context, Nan::Error(this-&gt;ErrorMessage())).FromJust();
}

template &lt;class GDALType&gt; GDALPromiseWorker&lt;GDALType&gt;::~GDALPromiseWorker() {
  delete context_handle;
  delete resolver_handle;
}

// This the basic unit of the GDALAsyncable framework
// GDALAsyncableJob is a GDAL job consisting of a main
// lambda that calls GDAL and rval lambda that transforms
// the return value
// It handles persistence of the referenced objects and
// can be executed both synchronously and asynchronously
//
// GDALType is the intermediary type that will be carried
// across the context boundaries
//
// The caller must ensure that all the lambdas can be executed in
// another thread:
// * no capturing of automatic variables (C++ memory management)
// * no referencing of JS-visible objects in main() (V8 memory management)
// * protecting all JS-visible objects from the GC by calling persist() (V8 MM)
// * locking all GDALDatasets (GDAL limitation)
//
// If a GDALDataset is locked, but not persisted, the GC could still
// try to free it - in this case it will stop the JS world and then it will wait
// on the Dataset lock in PtrManager::dispose() blocking the event loop - the situation
// is safe but it is still best if it is avoided (see the comments in ptr_manager.cpp)

template &lt;class GDALType&gt; class GDALAsyncableJob {
    public:
  typedef std::function&lt;GDALType(const GDALExecutionProgress &amp;)&gt; GDALMainFunc;
  typedef std::function&lt;v8::Local&lt;v8::Value&gt;(const GDALType, const GetFromPersistentFunc &amp;)&gt; GDALRValFunc;
  // This is the lambda that produces the &lt;GDALType&gt; object
  GDALMainFunc main;
  // This is the lambda that produces the JS return object from the &lt;GDALType&gt; object
  GDALRValFunc rval;
  Nan::Callback *progress;

  GDALAsyncableJob(long ds_uid) : main(), rval(), progress(nullptr), persistent(), ds_uids({ds_uid}), autoIndex(0){};
  GDALAsyncableJob(std::vector&lt;long&gt; ds_uids)
    : main(), rval(), progress(nullptr), persistent(), ds_uids(ds_uids), autoIndex(0){};

  inline void persist(const std::string &amp;key, const v8::Local&lt;v8::Object&gt; &amp;obj) {
    persistent[key] = obj;
  }

  inline void persist(const v8::Local&lt;v8::Object&gt; &amp;obj) {
    persistent[std::to_string(autoIndex++)] = obj;
  }

  inline void persist(const v8::Local&lt;v8::Object&gt; &amp;obj1, const v8::Local&lt;v8::Object&gt; &amp;obj2) {
    persist(obj1);
    persist(obj2);
  }

  inline void persist(const std::vector&lt;v8::Local&lt;v8::Object&gt;&gt; &amp;objs) {
    for (auto const &amp;i : objs) persist(i);
  }

  void run(const Nan::FunctionCallbackInfo&lt;v8::Value&gt; &amp;info, bool async, int cb_arg) {
    if (async) {
      if (progress) persist(&quot;progress_cb&quot;, progress-&gt;GetFunction());
      if (!info.This().IsEmpty() &amp;&amp; info.This()-&gt;IsObject()) persist(&quot;this&quot;, info.This());
      Nan::Callback *callback;
      NODE_ARG_CB(cb_arg, &quot;callback&quot;, callback);
      Nan::AsyncQueueWorker(new GDALCallbackWorker&lt;GDALType&gt;(callback, progress, main, rval, persistent, ds_uids));
      return;
    }
    try {
      GDALExecutionProgress executionProgress(new GDALSyncExecutionProgress(progress));
      AsyncGuard lock(ds_uids, eventLoopWarn);
      GDALType obj = main(executionProgress);
      // rval is the user function that will create the returned value
      // we give it a lambda that can access the persistent storage created for this operation
      info.GetReturnValue().Set(rval(obj, [this](const char *key) { return this-&gt;persistent[key]; }));
    } catch (const char *err) { Nan::ThrowError(err); }
  }

  void run(Nan::NAN_GETTER_ARGS_TYPE info, bool async) {
    if (async) {
      if (!info.This().IsEmpty() &amp;&amp; info.This()-&gt;IsObject()) persist(&quot;this&quot;, info.This());
      auto worker = new GDALPromiseWorker&lt;GDALType&gt;(info, main, rval, persistent, ds_uids);
      info.GetReturnValue().Set(worker-&gt;Promise());
      Nan::AsyncQueueWorker(worker);
      return;
    }
    try {
      GDALExecutionProgress executionProgress(new GDALSyncExecutionProgress(progress));
      AsyncGuard lock(ds_uids, eventLoopWarn);
      GDALType obj = main(executionProgress);
      // rval is the user function that will create the returned value
      // we give it a lambda that can access the persistent storage created for this operation
      info.GetReturnValue().Set(rval(obj, [this](const char *key) { return this-&gt;persistent[key]; }));
    } catch (const char *err) { Nan::ThrowError(err); }
  }

    private:
  std::map&lt;std::string, v8::Local&lt;v8::Object&gt;&gt; persistent;
  const std::vector&lt;long&gt; ds_uids;
  unsigned autoIndex;
};
} // namespace node_gdal
#endif
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
