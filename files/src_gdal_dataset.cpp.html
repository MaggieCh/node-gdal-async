<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/gdal_dataset.cpp - node-gdal-async</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-async" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-async">
            node-gdal-async
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>3.4.3</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DIM)", "classes/Constants (DIR)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GPI)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.ArrayAttributes", "classes/gdal.ArrayDimensions", "classes/gdal.Attribute", "classes/gdal.CircularString", "classes/gdal.ColorTable", "classes/gdal.CompoundCurve", "classes/gdal.CompoundCurveCurves", "classes/gdal.config", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Dimension", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.fs", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Group", "classes/gdal.GroupArrays", "classes/gdal.GroupAttributes", "classes/gdal.GroupDimensions", "classes/gdal.GroupGroups", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MDArray", "classes/gdal.MultiCurve", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.RasterMuxStream", "classes/gdal.RasterReadStream", "classes/gdal.RasterTransform", "classes/gdal.RasterWriteStream", "classes/gdal.SimpleCurve", "classes/gdal.SpatialReference", "classes/gdal.vsimem"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DIM).html">Constants (DIM)</a></li>
                <li><a href="../classes/Constants (DIR).html">Constants (DIR)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GPI).html">Constants (GPI)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.ArrayAttributes.html">gdal.ArrayAttributes</a></li>
                <li><a href="../classes/gdal.ArrayDimensions.html">gdal.ArrayDimensions</a></li>
                <li><a href="../classes/gdal.Attribute.html">gdal.Attribute</a></li>
                <li><a href="../classes/gdal.CircularString.html">gdal.CircularString</a></li>
                <li><a href="../classes/gdal.ColorTable.html">gdal.ColorTable</a></li>
                <li><a href="../classes/gdal.CompoundCurve.html">gdal.CompoundCurve</a></li>
                <li><a href="../classes/gdal.CompoundCurveCurves.html">gdal.CompoundCurveCurves</a></li>
                <li><a href="../classes/gdal.config.html">gdal.config</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Dimension.html">gdal.Dimension</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.fs.html">gdal.fs</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Group.html">gdal.Group</a></li>
                <li><a href="../classes/gdal.GroupArrays.html">gdal.GroupArrays</a></li>
                <li><a href="../classes/gdal.GroupAttributes.html">gdal.GroupAttributes</a></li>
                <li><a href="../classes/gdal.GroupDimensions.html">gdal.GroupDimensions</a></li>
                <li><a href="../classes/gdal.GroupGroups.html">gdal.GroupGroups</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MDArray.html">gdal.MDArray</a></li>
                <li><a href="../classes/gdal.MultiCurve.html">gdal.MultiCurve</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.RasterMuxStream.html">gdal.RasterMuxStream</a></li>
                <li><a href="../classes/gdal.RasterReadStream.html">gdal.RasterReadStream</a></li>
                <li><a href="../classes/gdal.RasterTransform.html">gdal.RasterTransform</a></li>
                <li><a href="../classes/gdal.RasterWriteStream.html">gdal.RasterWriteStream</a></li>
                <li><a href="../classes/gdal.SimpleCurve.html">gdal.SimpleCurve</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
                <li><a href="../classes/gdal.vsimem.html">gdal.vsimem</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/gdal_dataset.cpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
#include &quot;gdal_dataset.hpp&quot;
#include &quot;gdal_group.hpp&quot;
#include &quot;collections/dataset_bands.hpp&quot;
#include &quot;collections/dataset_layers.hpp&quot;
#include &quot;gdal_common.hpp&quot;
#include &quot;gdal_driver.hpp&quot;
#include &quot;geometry/gdal_geometry.hpp&quot;
#include &quot;gdal_layer.hpp&quot;
#include &quot;gdal_majorobject.hpp&quot;
#include &quot;gdal_rasterband.hpp&quot;
#include &quot;gdal_spatial_reference.hpp&quot;
#include &quot;utils/string_list.hpp&quot;

namespace node_gdal {

Nan::Persistent&lt;FunctionTemplate&gt; Dataset::constructor;

void Dataset::Initialize(Local&lt;Object&gt; target) {
  Nan::HandleScope scope;

  Local&lt;FunctionTemplate&gt; lcons = Nan::New&lt;FunctionTemplate&gt;(Dataset::New);
  lcons-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  lcons-&gt;SetClassName(Nan::New(&quot;Dataset&quot;).ToLocalChecked());

  Nan::SetPrototypeMethod(lcons, &quot;toString&quot;, toString);
  Nan::SetPrototypeMethod(lcons, &quot;setGCPs&quot;, setGCPs);
  Nan::SetPrototypeMethod(lcons, &quot;getGCPs&quot;, getGCPs);
  Nan::SetPrototypeMethod(lcons, &quot;getGCPProjection&quot;, getGCPProjection);
  Nan::SetPrototypeMethod(lcons, &quot;getFileList&quot;, getFileList);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;flush&quot;, flush);
  Nan::SetPrototypeMethod(lcons, &quot;close&quot;, close);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;getMetadata&quot;, getMetadata);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;setMetadata&quot;, setMetadata);
  Nan::SetPrototypeMethod(lcons, &quot;testCapability&quot;, testCapability);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;executeSQL&quot;, executeSQL);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;buildOverviews&quot;, buildOverviews);

  ATTR_DONT_ENUM(lcons, &quot;_uid&quot;, uidGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;description&quot;, descriptionGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;bands&quot;, bandsGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;layers&quot;, layersGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;rasterSize&quot;, rasterSizeGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;driver&quot;, driverGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;root&quot;, rootGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;srs&quot;, srsGetter, srsSetter);
  ATTR_ASYNCABLE(lcons, &quot;geoTransform&quot;, geoTransformGetter, geoTransformSetter);

  Nan::Set(target, Nan::New(&quot;Dataset&quot;).ToLocalChecked(), Nan::GetFunction(lcons).ToLocalChecked());

  constructor.Reset(lcons);
}

Dataset::Dataset(GDALDataset *ds) : Nan::ObjectWrap(), uid(0), parent_uid(0), this_dataset(ds), parent_ds(nullptr) {
  LOG(&quot;Created Dataset [%p]&quot;, ds);
}

Dataset::~Dataset() {
  // Destroy at garbage collection time if not already explicitly destroyed
  dispose(false);
}

void Dataset::dispose(bool manual) {
  if (this_dataset) {
    LOG(&quot;Disposing Dataset [%p]&quot;, this_dataset);

    object_store.dispose(uid, manual);

    LOG(&quot;Disposed Dataset [%p]&quot;, this_dataset);

    this_dataset = NULL;
  }
}

/**
 * A set of associated raster bands and/or vector layers, usually from one file.
 *
 * &#x60;&#x60;&#x60;
 * // raster dataset:
 * dataset = gdal.open(&#x27;file.tif&#x27;);
 * bands = dataset.bands;
 *
 * // vector dataset:
 * dataset = gdal.open(&#x27;file.shp&#x27;);
 * layers = dataset.layers;&#x60;&#x60;&#x60;
 *
 * @class gdal.Dataset
 */
NAN_METHOD(Dataset::New) {

  if (!info.IsConstructCall()) {
    Nan::ThrowError(&quot;Cannot call constructor as function, you need to use &#x27;new&#x27; keyword&quot;);
    return;
  }
  if (info[0]-&gt;IsExternal()) {
    Local&lt;External&gt; ext = info[0].As&lt;External&gt;();
    void *ptr = ext-&gt;Value();
    Dataset *f = static_cast&lt;Dataset *&gt;(ptr);
    f-&gt;Wrap(info.This());

    Local&lt;Value&gt; layers = DatasetLayers::New(info.This());
    Nan::SetPrivate(info.This(), Nan::New(&quot;layers_&quot;).ToLocalChecked(), layers);

    Local&lt;Value&gt; rootObj, bandsObj;
#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)
    GDALDataset *gdal_ds = f-&gt;get();
    std::shared_ptr&lt;GDALGroup&gt; root = gdal_ds-&gt;GetRootGroup();
    if (root == nullptr) {
#endif
      bandsObj = DatasetBands::New(info.This());
#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)
    } else {
      bandsObj = Nan::Null();
    }
#endif
    Nan::SetPrivate(info.This(), Nan::New(&quot;bands_&quot;).ToLocalChecked(), bandsObj);
    if (f-&gt;parent_ds)
      // For dependent Datasets, keep a reference on the parent to protect it from the GC
      Nan::SetPrivate(info.This(), Nan::New(&quot;parent_&quot;).ToLocalChecked(), object_store.get(f-&gt;parent_ds));

    info.GetReturnValue().Set(info.This());
    return;
  } else {
    Nan::ThrowError(&quot;Cannot create dataset directly&quot;);
    return;
  }
}

Local&lt;Value&gt; Dataset::New(GDALDataset *raw, GDALDataset *parent) {
  Nan::EscapableHandleScope scope;

  if (!raw) { return scope.Escape(Nan::Null()); }
  if (object_store.has(raw)) { return scope.Escape(object_store.get(raw)); }

  Dataset *wrapped = new Dataset(raw);

  long parent_uid = 0;
  if (parent != nullptr) {
    /* A dependent Dataset shares the lock of its parent
     */
    Dataset *parent_ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(object_store.get(parent));
    parent_uid = parent_ds-&gt;uid;
  }

  Local&lt;Value&gt; ext = Nan::New&lt;External&gt;(wrapped);
  Local&lt;Object&gt; obj =
    Nan::NewInstance(Nan::GetFunction(Nan::New(Dataset::constructor)).ToLocalChecked(), 1, &amp;ext).ToLocalChecked();

  wrapped-&gt;uid = object_store.add(raw, wrapped-&gt;persistent(), parent_uid);

  return scope.Escape(obj);
}

NAN_METHOD(Dataset::toString) {
  info.GetReturnValue().Set(Nan::New(&quot;Dataset&quot;).ToLocalChecked());
}

/**
 * Fetch metadata.
 *
 * @method getMetadata
 * @param {string} [domain]
 * @return {any}
 */

/**
 * Fetch metadata.
 * {{{async}}}
 *
 * @method getMetadataAsync
 * @param {string} [domain]
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;any&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Dataset::getMetadata) {
  NODE_UNWRAP_CHECK(Dataset, info.This(), ds);
  GDAL_RAW_CHECK(GDALDataset *, ds, raw);

  std::string domain(&quot;&quot;);
  NODE_ARG_OPT_STR(0, &quot;domain&quot;, domain);

  GDALAsyncableJob&lt;char **&gt; job(ds-&gt;uid);
  job.main = [raw, domain](const GDALExecutionProgress &amp;) {
    return raw-&gt;GetMetadata(domain.empty() ? nullptr : domain.c_str());
  };
  job.rval = [](char **md, const GetFromPersistentFunc &amp;) { return MajorObject::getMetadata(md); };
  job.run(info, async, 1);
}

/**
 * Set metadata. Can return a warning (false) for formats not supporting persistent metadata.
 *
 * @method setMetadata
 * @param {object|string[]} metadata
 * @param {string} [domain]
 * @return {boolean}
 */

/**
 * Set metadata. Can return a warning (false) for formats not supporting persistent metadata.
 * {{{async}}}
 *
 * @method setMetadataAsync
 * @param {object|string[]} metadata
 * @param {string} [domain]
 * @param {callback&lt;boolean&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;boolean&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Dataset::setMetadata) {
  NODE_UNWRAP_CHECK(Dataset, info.This(), ds);
  GDAL_RAW_CHECK(GDALDataset *, ds, raw);

  auto options = make_shared&lt;StringList&gt;();
  if (info.Length() == 0 || options-&gt;parse(info[0])) {
    Nan::ThrowError(&quot;Failed parsing metadata&quot;);
    return;
  }

  std::string domain(&quot;&quot;);
  NODE_ARG_OPT_STR(1, &quot;domain&quot;, domain);

  GDALAsyncableJob&lt;CPLErr&gt; job(ds-&gt;uid);
  job.main = [raw, options, domain](const GDALExecutionProgress &amp;) {
    CPLErr r = raw-&gt;SetMetadata(options-&gt;get(), domain.empty() ? nullptr : domain.c_str());
    if (r == CE_Failure) throw CPLGetLastErrorMsg();
    return r;
  };
  job.rval = [](CPLErr r, const GetFromPersistentFunc &amp;) { return Nan::New&lt;Boolean&gt;(r == CE_None); };
  job.run(info, async, 2);
}

/**
 * Determines if the dataset supports the indicated operation.
 *
 * @method testCapability
 * @param {string} capability (see {{#crossLink &quot;Constants (ODsC)&quot;}}capability
 * list{{/crossLink}})
 * @return {boolean}
 */
NAN_METHOD(Dataset::testCapability) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();

  std::string capability(&quot;&quot;);
  NODE_ARG_STR(0, &quot;capability&quot;, capability);

  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  info.GetReturnValue().Set(Nan::New&lt;Boolean&gt;(raw-&gt;TestCapability(capability.c_str())));
}

/**
 * Get output projection for GCPs.
 *
 * @method getGCPProjection
 * @return {string}
 */
NAN_METHOD(Dataset::getGCPProjection) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  info.GetReturnValue().Set(SafeString::New(raw-&gt;GetGCPProjection()));
}

/**
 * Closes the dataset to further operations. It releases all memory and ressources held
 * by the dataset.
 * This is normally an instantenous atomic operation that won&#x27;t block the event loop
 * except if there is an operation running on this dataset in asynchronous context - in this case
 * this call will block until that operation finishes.
 *
 * If this could potentially be the case and blocking the event loop is not possible (server code),
 * then the best option is to simply dereference it (ds = null) and leave
 * the garbage collector to expire it.
 *
 * Implementing an asynchronous delete is difficult since all V8 object creation/deletion
 * must take place on the main thread.
 *
 * flush[Async]() ensures that, when writing, all data has been written.
 *
 * @method close
 */
NAN_METHOD(Dataset::close) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  ds-&gt;dispose(true);

  return;
}

/**
 * Flushes all changes to disk.
 *
 * @throws Error
 * @method flush
 */

/**
 * Flushes all changes to disk.
 * {{{async}}}
 *
 * @method flushAsync
 * @throws Error
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Dataset::flush) {
  NODE_UNWRAP_CHECK(Dataset, info.This(), ds);
  GDAL_RAW_CHECK(GDALDataset *, ds, raw);
  GDALAsyncableJob&lt;int&gt; job(ds-&gt;uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    raw-&gt;FlushCache();
    return 0;
  };
  job.rval = [](int, const GetFromPersistentFunc &amp;) { return Nan::Undefined().As&lt;Value&gt;(); };
  job.run(info, async, 0);

  return;
}

/**
 * Execute an SQL statement against the data store.
 *
 * @throws Error
 * @method executeSQL
 * @param {string} statement SQL statement to execute.
 * @param {gdal.Geometry} [spatial_filter=null] Geometry which represents a
 * spatial filter.
 * @param {string} [dialect=null] Allows control of the statement dialect. If
 * set to &#x60;null&#x60;, the OGR SQL engine will be used, except for RDBMS drivers that
 * will use their dedicated SQL engine, unless &#x60;&quot;OGRSQL&quot;&#x60; is explicitely passed
 * as the dialect. Starting with OGR 1.10, the &#x60;&quot;SQLITE&quot;&#x60; dialect can also be
 * used.
 * @return {gdal.Layer}
 */

/**
 * Execute an SQL statement against the data store.
 * {{{async}}}
 *
 * @throws Error
 * @method executeSQLAsync
 * @param {string} statement SQL statement to execute.
 * @param {gdal.Geometry} [spatial_filter=null] Geometry which represents a
 * spatial filter.
 * @param {string} [dialect=null] Allows control of the statement dialect. If
 * set to &#x60;null&#x60;, the OGR SQL engine will be used, except for RDBMS drivers that
 * will use their dedicated SQL engine, unless &#x60;&quot;OGRSQL&quot;&#x60; is explicitely passed
 * as the dialect. Starting with OGR 1.10, the &#x60;&quot;SQLITE&quot;&#x60; dialect can also be
 * used.
 * @param {callback&lt;gdal.Layer&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;gdal.Layer&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Dataset::executeSQL) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();

  std::string sql;
  std::string sql_dialect;
  Geometry *spatial_filter = NULL;

  NODE_ARG_STR(0, &quot;sql text&quot;, sql);
  NODE_ARG_WRAPPED_OPT(1, &quot;spatial filter geometry&quot;, Geometry, spatial_filter);
  NODE_ARG_OPT_STR(2, &quot;sql dialect&quot;, sql_dialect);

  GDALAsyncableJob&lt;OGRLayer *&gt; job(ds-&gt;uid);
  OGRGeometry *geom_filter = spatial_filter ? spatial_filter-&gt;get() : NULL;
  job.main = [raw, sql, sql_dialect, geom_filter](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    OGRLayer *layer = raw-&gt;ExecuteSQL(sql.c_str(), geom_filter, sql_dialect.empty() ? NULL : sql_dialect.c_str());
    if (layer == nullptr) throw CPLGetLastErrorMsg();
    return layer;
  };
  job.rval = [raw](OGRLayer *layer, const GetFromPersistentFunc &amp;) { return Layer::New(layer, raw, true); };

  job.run(info, async, 3);
}

/**
 * Fetch files forming dataset.
 *
 * Returns a list of files believed to be part of this dataset. If it returns an
 * empty list of files it means there is believed to be no local file system
 * files associated with the dataset (for instance a virtual dataset).
 *
 * Returns an empty array for vector datasets if GDAL version is below 2.0
 *
 * @method getFileList
 * @return {string[]}
 */
NAN_METHOD(Dataset::getFileList) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  Local&lt;Array&gt; results = Nan::New&lt;Array&gt;(0);

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  if (!raw) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  char **list = raw-&gt;GetFileList();
  if (!list) {
    info.GetReturnValue().Set(results);
    return;
  }

  int i = 0;
  while (list[i]) {
    Nan::Set(results, i, SafeString::New(list[i]));
    i++;
  }

  CSLDestroy(list);

  info.GetReturnValue().Set(results);
}

/**
 * Fetches GCPs.
 *
 * @method getGCPs
 * @return {any[]}
 */
NAN_METHOD(Dataset::getGCPs) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  Local&lt;Array&gt; results = Nan::New&lt;Array&gt;(0);

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  if (!raw) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  int n = raw-&gt;GetGCPCount();
  const GDAL_GCP *gcps = raw-&gt;GetGCPs();

  if (!gcps) {
    info.GetReturnValue().Set(results);
    return;
  }

  for (int i = 0; i &lt; n; i++) {
    GDAL_GCP gcp = gcps[i];
    Local&lt;Object&gt; obj = Nan::New&lt;Object&gt;();
    Nan::Set(obj, Nan::New(&quot;pszId&quot;).ToLocalChecked(), Nan::New(gcp.pszId).ToLocalChecked());
    Nan::Set(obj, Nan::New(&quot;pszInfo&quot;).ToLocalChecked(), Nan::New(gcp.pszInfo).ToLocalChecked());
    Nan::Set(obj, Nan::New(&quot;dfGCPPixel&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(gcp.dfGCPPixel));
    Nan::Set(obj, Nan::New(&quot;dfGCPLine&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(gcp.dfGCPLine));
    Nan::Set(obj, Nan::New(&quot;dfGCPX&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(gcp.dfGCPX));
    Nan::Set(obj, Nan::New(&quot;dfGCPY&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(gcp.dfGCPY));
    Nan::Set(obj, Nan::New(&quot;dfGCPZ&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(gcp.dfGCPZ));
    Nan::Set(results, i, obj);
  }

  info.GetReturnValue().Set(results);
}

/**
 * Sets GCPs.
 *
 * @throws Error
 * @method setGCPs
 * @param {object[]} gcps
 * @param {string} [projection]
 */
NAN_METHOD(Dataset::setGCPs) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  if (!raw) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  Local&lt;Array&gt; gcps;
  std::string projection(&quot;&quot;);
  NODE_ARG_ARRAY(0, &quot;gcps&quot;, gcps);
  NODE_ARG_OPT_STR(1, &quot;projection&quot;, projection);

  std::shared_ptr&lt;GDAL_GCP&gt; list(new GDAL_GCP[gcps-&gt;Length()], array_deleter&lt;GDAL_GCP&gt;());
  std::shared_ptr&lt;std::string&gt; pszId_list(new std::string[gcps-&gt;Length()], array_deleter&lt;std::string&gt;());
  std::shared_ptr&lt;std::string&gt; pszInfo_list(new std::string[gcps-&gt;Length()], array_deleter&lt;std::string&gt;());
  GDAL_GCP *gcp = list.get();
  for (unsigned int i = 0; i &lt; gcps-&gt;Length(); ++i) {
    Local&lt;Value&gt; val = Nan::Get(gcps, i).ToLocalChecked();
    if (!val-&gt;IsObject()) {
      Nan::ThrowError(&quot;GCP array must only include objects&quot;);
      return;
    }
    Local&lt;Object&gt; obj = val.As&lt;Object&gt;();

    NODE_DOUBLE_FROM_OBJ(obj, &quot;dfGCPPixel&quot;, gcp-&gt;dfGCPPixel);
    NODE_DOUBLE_FROM_OBJ(obj, &quot;dfGCPLine&quot;, gcp-&gt;dfGCPLine);
    NODE_DOUBLE_FROM_OBJ(obj, &quot;dfGCPX&quot;, gcp-&gt;dfGCPX);
    NODE_DOUBLE_FROM_OBJ(obj, &quot;dfGCPY&quot;, gcp-&gt;dfGCPY);
    NODE_DOUBLE_FROM_OBJ_OPT(obj, &quot;dfGCPZ&quot;, gcp-&gt;dfGCPZ);
    NODE_STR_FROM_OBJ_OPT(obj, &quot;pszId&quot;, pszId_list.get()[i]);
    NODE_STR_FROM_OBJ_OPT(obj, &quot;pszInfo&quot;, pszInfo_list.get()[i]);

    gcp-&gt;pszId = (char *)pszId_list.get()[i].c_str();
    gcp-&gt;pszInfo = (char *)pszInfo_list.get()[i].c_str();

    gcp++;
  }

  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  CPLErr err = raw-&gt;SetGCPs(gcps-&gt;Length(), list.get(), projection.c_str());

  if (err) {
    NODE_THROW_LAST_CPLERR;
    return;
  }

  return;
}

/**
 * Builds dataset overviews.
 *
 * @throws Error
 * @method buildOverviews
 * @param {string} resampling &#x60;&quot;NEAREST&quot;&#x60;, &#x60;&quot;GAUSS&quot;&#x60;, &#x60;&quot;CUBIC&quot;&#x60;, &#x60;&quot;AVERAGE&quot;&#x60;,
 * &#x60;&quot;MODE&quot;&#x60;, &#x60;&quot;AVERAGE_MAGPHASE&quot;&#x60; or &#x60;&quot;NONE&quot;&#x60;
 * @param {number[]} overviews
 * @param {number[]} [bands] Note: Generation of overviews in external TIFF currently only supported when operating on all bands.
 * @param {ProgressOptions} [options] options
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 */

/**
 * Builds dataset overviews.
 * {{{async}}}
 *
 * @throws Error
 * @method buildOverviewsAsync
 * @param {string} resampling &#x60;&quot;NEAREST&quot;&#x60;, &#x60;&quot;GAUSS&quot;&#x60;, &#x60;&quot;CUBIC&quot;&#x60;, &#x60;&quot;AVERAGE&quot;&#x60;,
 * &#x60;&quot;MODE&quot;&#x60;, &#x60;&quot;AVERAGE_MAGPHASE&quot;&#x60; or &#x60;&quot;NONE&quot;&#x60;
 * @param {number[]} overviews
 * @param {number[]} [bands] Note: Generation of overviews in external TIFF currently only supported when operating on all bands.
 * @param {ProgressOptions} [options] options
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Dataset::buildOverviews) {

  NODE_UNWRAP_CHECK(Dataset, info.This(), ds);
  GDAL_RAW_CHECK(GDALDataset *, ds, raw);

  std::string resampling = &quot;&quot;;
  Local&lt;Array&gt; overviews;
  Local&lt;Array&gt; bands;

  NODE_ARG_STR(0, &quot;resampling&quot;, resampling);
  NODE_ARG_ARRAY(1, &quot;overviews&quot;, overviews);
  NODE_ARG_ARRAY_OPT(2, &quot;bands&quot;, bands);

  int n_overviews = overviews-&gt;Length();
  int i, n_bands = 0;

  // shared_ptr to array is C++17 :(
  std::shared_ptr&lt;int&gt; o(new int[n_overviews], array_deleter&lt;int&gt;());
  std::shared_ptr&lt;int&gt; b;
  for (i = 0; i &lt; n_overviews; i++) {
    Local&lt;Value&gt; val = Nan::Get(overviews, i).ToLocalChecked();
    if (!val-&gt;IsNumber()) {
      Nan::ThrowError(&quot;overviews array must only contain numbers&quot;);
      return;
    }
    o.get()[i] = Nan::To&lt;int32_t&gt;(val).ToChecked();
  }

  if (!bands.IsEmpty()) {
    n_bands = bands-&gt;Length();
    b = std::shared_ptr&lt;int&gt;(new int[n_bands], array_deleter&lt;int&gt;());
    for (i = 0; i &lt; n_bands; i++) {
      Local&lt;Value&gt; val = Nan::Get(bands, i).ToLocalChecked();
      if (!val-&gt;IsNumber()) {
        Nan::ThrowError(&quot;band array must only contain numbers&quot;);
        return;
      }
      b.get()[i] = Nan::To&lt;int32_t&gt;(val).ToChecked();
    }
  }

  GDALAsyncableJob&lt;CPLErr&gt; job(ds-&gt;uid);

  Nan::Callback *progress_cb;
  NODE_PROGRESS_CB_OPT(3, progress_cb, job);
  job.progress = progress_cb;
  // Alas one cannot capture-move a unique_ptr and assign the lambda to a variable
  // because the lambda becomes non-copyable
  // But we can use a shared_ptr because the lifetime of the lambda is limited by the lifetime
  // of the async worker
  job.main = [raw, resampling, n_overviews, o, n_bands, b, progress_cb](const GDALExecutionProgress &amp;progress) {
    if (b != nullptr) {
      for (int i = 0; i &lt; n_bands; i++) {
        if (b.get()[i] &gt; raw-&gt;GetRasterCount() || b.get()[i] &lt; 1) { throw &quot;invalid band id&quot;; }
      }
    }
    CPLErrorReset();
    CPLErr err = raw-&gt;BuildOverviews(
      resampling.c_str(),
      n_overviews,
      o.get(),
      n_bands,
      b.get(),
      progress_cb ? ProgressTrampoline : nullptr,
      progress_cb ? (void *)&amp;progress : nullptr);
    if (err != CE_None) { throw CPLGetLastErrorMsg(); }
    return err;
  };
  job.rval = [](CPLErr, const GetFromPersistentFunc &amp;) { return Nan::Undefined().As&lt;Value&gt;(); };

  job.run(info, async, 4);
}

/**
 * @readOnly
 * @attribute description
 * @type {string}
 */
NAN_GETTER(Dataset::descriptionGetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  if (!raw) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }
  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  info.GetReturnValue().Set(SafeString::New(raw-&gt;GetDescription()));
}

/**
 * Raster dimensions. An object containing &#x60;x&#x60; and &#x60;y&#x60; properties.
 *
 * @readOnly
 * @attribute rasterSize
 * @type {xyz}
 */

/**
 * Raster dimensions. An object containing &#x60;x&#x60; and &#x60;y&#x60; properties.
 * {{async_getter}}
 *
 * @readOnly
 * @attribute rasterSizeAsync
 * @type {Promise&lt;xyz&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(Dataset::rasterSizeGetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());
  struct xy {
    int x, y;
    bool null;
  };

  if (!ds-&gt;isAlive()) {
    THROW_OR_REJECT(&quot;Dataset object has already been destroyed&quot;)
    return;
  }

  GDALDataset *raw = ds-&gt;get();

  GDALAsyncableJob&lt;xy&gt; job(ds-&gt;uid);

  job.main = [raw](const GDALExecutionProgress &amp;) {
    xy result;
    // GDAL 2.x will return 512x512 for vector datasets... which doesn&#x27;t really make
    // sense in JS where we can return null instead of a number
    // https://github.com/OSGeo/gdal/blob/beef45c130cc2778dcc56d85aed1104a9b31f7e6/gdal/gcore/gdaldataset.cpp#L173-L174
    if (raw-&gt;GetDriver() == nullptr || !raw-&gt;GetDriver()-&gt;GetMetadataItem(GDAL_DCAP_RASTER)) {
      result.null = true;
      return result;
    }
    result.x = raw-&gt;GetRasterXSize();
    result.y = raw-&gt;GetRasterYSize();
    result.null = false;
    return result;
  };

  job.rval = [](xy xy, const GetFromPersistentFunc &amp;) {
    Nan::EscapableHandleScope scope;
    if (xy.null) return Nan::Null().As&lt;Value&gt;();
    Local&lt;Object&gt; result = Nan::New&lt;Object&gt;();
    Nan::Set(result, Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;(xy.x));
    Nan::Set(result, Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;(xy.y));
    return scope.Escape(result.As&lt;Value&gt;());
  };

  job.run(info, async);
}

/**
 * Spatial reference associated with raster dataset
 *
 * @throws Error
 * @attribute srs
 * @type {gdal.SpatialReference|null}
 */

/**
 * Spatial reference associated with raster dataset
 * {{async_getter}}
 *
 * @throws Error
 * @attribute srsAsync
 * @readOnly
 * @type {Promise&lt;gdal.SpatialReference|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(Dataset::srsGetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    THROW_OR_REJECT(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();

  GDALAsyncableJob&lt;OGRSpatialReference *&gt; job(ds-&gt;uid);

  job.main = [raw](const GDALExecutionProgress &amp;) {
    // get projection wkt and return null if not set
    OGRChar *wkt = (OGRChar *)raw-&gt;GetProjectionRef();
    if (*wkt == &#x27;\0&#x27;) {
      // getProjectionRef returns string of length 0 if no srs set
      return (OGRSpatialReference *)nullptr;
    }
    // otherwise construct and return SpatialReference from wkt
    OGRSpatialReference *srs = new OGRSpatialReference();
    int err = srs-&gt;importFromWkt(&amp;wkt);
    if (err) throw getOGRErrMsg(err);
    return srs;
  };

  job.rval = [](OGRSpatialReference *srs, const GetFromPersistentFunc &amp;) {
    if (srs != nullptr)
      return SpatialReference::New(srs, true);
    else
      return Nan::Null().As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * An affine transform which maps pixel/line coordinates into georeferenced
 * space using the following relationship:
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var GT = dataset.geoTransform;
 * var Xgeo = GT[0] + Xpixel*GT[1] + Yline*GT[2];
 * var Ygeo = GT[3] + Xpixel*GT[4] + Yline*GT[5];&#x60;&#x60;&#x60;
 *
 * @attribute geoTransform
 * @type {number[]|null}
 */

/**
 * An affine transform which maps pixel/line coordinates into georeferenced
 * space using the following relationship:
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var GT = dataset.geoTransform;
 * var Xgeo = GT[0] + Xpixel*GT[1] + Yline*GT[2];
 * var Ygeo = GT[3] + Xpixel*GT[4] + Yline*GT[5];&#x60;&#x60;&#x60;
 *
 * {{async_getter}}
 * @readOnly
 * @attribute geoTransformAsync
 * @type {Promise&lt;number[]|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(Dataset::geoTransformGetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    THROW_OR_REJECT(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();

  GDALAsyncableJob&lt;std::shared_ptr&lt;double&gt;&gt; job(ds-&gt;uid);

  job.main = [raw](const GDALExecutionProgress &amp;) {
    auto transform = std::shared_ptr&lt;double&gt;(new double[6], array_deleter&lt;double&gt;());
    CPLErr err = raw-&gt;GetGeoTransform(transform.get());
    // This is mostly (always?) a sign that it has not been set
    if (err) { return std::shared_ptr&lt;double&gt;(nullptr); }
    return transform;
  };

  job.rval = [](std::shared_ptr&lt;double&gt; transform, const GetFromPersistentFunc &amp;) {
    if (transform == nullptr) return Nan::Null().As&lt;v8::Value&gt;();
    Local&lt;Array&gt; result = Nan::New&lt;Array&gt;(6);
    Nan::Set(result, 0, Nan::New&lt;Number&gt;(transform.get()[0]));
    Nan::Set(result, 1, Nan::New&lt;Number&gt;(transform.get()[1]));
    Nan::Set(result, 2, Nan::New&lt;Number&gt;(transform.get()[2]));
    Nan::Set(result, 3, Nan::New&lt;Number&gt;(transform.get()[3]));
    Nan::Set(result, 4, Nan::New&lt;Number&gt;(transform.get()[4]));
    Nan::Set(result, 5, Nan::New&lt;Number&gt;(transform.get()[5]));

    return result.As&lt;v8::Value&gt;();
  };

  job.run(info, async);
}

/**
 * @readOnly
 * @attribute driver
 * @type {gdal.Driver}
 */
NAN_GETTER(Dataset::driverGetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  if (raw-&gt;GetDriver() != nullptr) { info.GetReturnValue().Set(Driver::New(raw-&gt;GetDriver())); }
}

NAN_SETTER(Dataset::srsSetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();
  std::string wkt(&quot;&quot;);
  if (IS_WRAPPED(value, SpatialReference)) {

    SpatialReference *srs_obj = Nan::ObjectWrap::Unwrap&lt;SpatialReference&gt;(value.As&lt;Object&gt;());
    OGRSpatialReference *srs = srs_obj-&gt;get();
    // Get wkt from OGRSpatialReference
    char *str;
    if (srs-&gt;exportToWkt(&amp;str)) {
      Nan::ThrowError(&quot;Error exporting srs to wkt&quot;);
      return;
    }
    wkt = str; // copy string
    CPLFree(str);

  } else if (!value-&gt;IsNull() &amp;&amp; !value-&gt;IsUndefined()) {
    Nan::ThrowError(&quot;srs must be SpatialReference object&quot;);
    return;
  }

  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  CPLErr err = raw-&gt;SetProjection(wkt.c_str());

  if (err) { NODE_THROW_LAST_CPLERR; }
}

NAN_SETTER(Dataset::geoTransformSetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());

  if (!ds-&gt;isAlive()) {
    Nan::ThrowError(&quot;Dataset object has already been destroyed&quot;);
    return;
  }

  GDALDataset *raw = ds-&gt;get();

  if (!value-&gt;IsArray()) {
    Nan::ThrowError(&quot;Transform must be an array&quot;);
    return;
  }
  Local&lt;Array&gt; transform = value.As&lt;Array&gt;();

  if (transform-&gt;Length() != 6) {
    Nan::ThrowError(&quot;Transform array must have 6 elements&quot;);
    return;
  }

  double buffer[6];
  for (int i = 0; i &lt; 6; i++) {
    Local&lt;Value&gt; val = Nan::Get(transform, i).ToLocalChecked();
    if (!val-&gt;IsNumber()) {
      Nan::ThrowError(&quot;Transform array must only contain numbers&quot;);
      return;
    }
    buffer[i] = Nan::To&lt;double&gt;(val).ToChecked();
  }

  AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
  CPLErr err = raw-&gt;SetGeoTransform(buffer);

  if (err) { NODE_THROW_LAST_CPLERR; }
}

/**
 * @readOnly
 * @attribute bands
 * @type {gdal.DatasetBands}
 */
NAN_GETTER(Dataset::bandsGetter) {
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;bands_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute layers
 * @type {gdal.DatasetLayers}
 */
NAN_GETTER(Dataset::layersGetter) {
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;layers_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute root
 * @type {gdal.Group}
 */
NAN_GETTER(Dataset::rootGetter) {
  Local&lt;Value&gt; rootObj = Nan::GetPrivate(info.This(), Nan::New(&quot;root_&quot;).ToLocalChecked()).ToLocalChecked();
  if (rootObj-&gt;IsUndefined()) {
#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)
    NODE_UNWRAP_CHECK(Dataset, info.This(), ds);
    GDAL_RAW_CHECK(GDALDataset *, ds, gdal_ds);
    AsyncGuard lock({ds-&gt;uid}, eventLoopWarn);
    std::shared_ptr&lt;GDALGroup&gt; root = gdal_ds-&gt;GetRootGroup();
    if (root == nullptr) {
#endif
      rootObj = Nan::Null();
#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)
    } else {
      rootObj = Group::New(root, info.This());
    }
#endif
    Nan::SetPrivate(info.This(), Nan::New(&quot;root_&quot;).ToLocalChecked(), rootObj);
  }
  info.GetReturnValue().Set(rootObj);
}

NAN_GETTER(Dataset::uidGetter) {
  Dataset *ds = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(info.This());
  info.GetReturnValue().Set(Nan::New((int)ds-&gt;uid));
}

} // namespace node_gdal

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
