<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/gdal_geometry.cpp - node-gdal-next</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-next" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-next">
            node-gdal-next
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.0.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.SpatialReference"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/gdal_geometry.cpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
#include &quot;gdal_common.hpp&quot;

#include &quot;gdal_coordinate_transformation.hpp&quot;
#include &quot;gdal_geometry.hpp&quot;
#include &quot;gdal_geometrycollection.hpp&quot;
#include &quot;gdal_linearring.hpp&quot;
#include &quot;gdal_linestring.hpp&quot;
#include &quot;gdal_multilinestring.hpp&quot;
#include &quot;gdal_multipoint.hpp&quot;
#include &quot;gdal_multipolygon.hpp&quot;
#include &quot;gdal_point.hpp&quot;
#include &quot;gdal_polygon.hpp&quot;
#include &quot;gdal_spatial_reference.hpp&quot;

#include &lt;node_buffer.h&gt;
#include &lt;ogr_core.h&gt;
#include &lt;memory&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;

namespace node_gdal {

Nan::Persistent&lt;FunctionTemplate&gt; Geometry::constructor;

void Geometry::Initialize(Local&lt;Object&gt; target) {
  Nan::HandleScope scope;

  Local&lt;FunctionTemplate&gt; lcons = Nan::New&lt;FunctionTemplate&gt;(Geometry::New);
  lcons-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  lcons-&gt;SetClassName(Nan::New(&quot;Geometry&quot;).ToLocalChecked());

  // Nan::SetMethod(constructor, &quot;fromWKBType&quot;, Geometry::create);
  Nan::SetMethod(lcons, &quot;fromWKT&quot;, Geometry::createFromWkt);
  Nan::SetMethod(lcons, &quot;fromWKTAsync&quot;, Geometry::createFromWktAsync);
  Nan::SetMethod(lcons, &quot;fromWKB&quot;, Geometry::createFromWkb);
  Nan::SetMethod(lcons, &quot;fromWKBAsync&quot;, Geometry::createFromWkbAsync);
  Nan::SetMethod(lcons, &quot;fromGeoJson&quot;, Geometry::createFromGeoJson);
  Nan::SetMethod(lcons, &quot;fromGeoJsonAsync&quot;, Geometry::createFromGeoJsonAsync);
  Nan::SetMethod(lcons, &quot;getName&quot;, Geometry::getName);
  Nan::SetMethod(lcons, &quot;getConstructor&quot;, Geometry::getConstructor);

  Nan::SetPrototypeMethod(lcons, &quot;toString&quot;, toString);
  Nan::SetPrototypeMethod(lcons, &quot;toKML&quot;, exportToKML);
  Nan::SetPrototypeMethod(lcons, &quot;toKMLAsync&quot;, exportToKMLAsync);
  Nan::SetPrototypeMethod(lcons, &quot;toGML&quot;, exportToGML);
  Nan::SetPrototypeMethod(lcons, &quot;toGMLAsync&quot;, exportToGMLAsync);
  Nan::SetPrototypeMethod(lcons, &quot;toJSON&quot;, exportToJSON);
  Nan::SetPrototypeMethod(lcons, &quot;toJSONAsync&quot;, exportToJSONAsync);
  Nan::SetPrototypeMethod(lcons, &quot;toWKT&quot;, exportToWKT);
  Nan::SetPrototypeMethod(lcons, &quot;toWKTAsync&quot;, exportToWKTAsync);
  Nan::SetPrototypeMethod(lcons, &quot;toWKB&quot;, exportToWKB);
  Nan::SetPrototypeMethod(lcons, &quot;toWKBAsync&quot;, exportToWKBAsync);
  Nan::SetPrototypeMethod(lcons, &quot;isEmpty&quot;, isEmpty);
  Nan::SetPrototypeMethod(lcons, &quot;isEmptyAsync&quot;, isEmptyAsync);
  Nan::SetPrototypeMethod(lcons, &quot;isValid&quot;, isValid);
  Nan::SetPrototypeMethod(lcons, &quot;isValidAsync&quot;, isValidAsync);
  Nan::SetPrototypeMethod(lcons, &quot;isSimple&quot;, isSimple);
  Nan::SetPrototypeMethod(lcons, &quot;isSimpleAsync&quot;, isSimpleAsync);
  Nan::SetPrototypeMethod(lcons, &quot;isRing&quot;, isRing);
  Nan::SetPrototypeMethod(lcons, &quot;isRingAsync&quot;, isRingAsync);
  Nan::SetPrototypeMethod(lcons, &quot;clone&quot;, clone);
  Nan::SetPrototypeMethod(lcons, &quot;empty&quot;, empty);
  Nan::SetPrototypeMethod(lcons, &quot;emptyAsync&quot;, emptyAsync);
  Nan::SetPrototypeMethod(lcons, &quot;closeRings&quot;, closeRings);
  Nan::SetPrototypeMethod(lcons, &quot;closeRingsAsync&quot;, closeRingsAsync);
  Nan::SetPrototypeMethod(lcons, &quot;intersects&quot;, intersects);
  Nan::SetPrototypeMethod(lcons, &quot;intersectsAsync&quot;, intersectsAsync);
  Nan::SetPrototypeMethod(lcons, &quot;equals&quot;, equals);
  Nan::SetPrototypeMethod(lcons, &quot;equalsAsync&quot;, equalsAsync);
  Nan::SetPrototypeMethod(lcons, &quot;disjoint&quot;, disjoint);
  Nan::SetPrototypeMethod(lcons, &quot;disjointAsync&quot;, disjointAsync);
  Nan::SetPrototypeMethod(lcons, &quot;touches&quot;, touches);
  Nan::SetPrototypeMethod(lcons, &quot;touchesAsync&quot;, touchesAsync);
  Nan::SetPrototypeMethod(lcons, &quot;crosses&quot;, crosses);
  Nan::SetPrototypeMethod(lcons, &quot;crossesAsync&quot;, crossesAsync);
  Nan::SetPrototypeMethod(lcons, &quot;within&quot;, within);
  Nan::SetPrototypeMethod(lcons, &quot;withinAsync&quot;, withinAsync);
  Nan::SetPrototypeMethod(lcons, &quot;contains&quot;, contains);
  Nan::SetPrototypeMethod(lcons, &quot;containsAsync&quot;, containsAsync);
  Nan::SetPrototypeMethod(lcons, &quot;overlaps&quot;, overlaps);
  Nan::SetPrototypeMethod(lcons, &quot;overlapsAsync&quot;, overlapsAsync);
  Nan::SetPrototypeMethod(lcons, &quot;boundary&quot;, boundary);
  Nan::SetPrototypeMethod(lcons, &quot;boundaryAsync&quot;, boundaryAsync);
  Nan::SetPrototypeMethod(lcons, &quot;distance&quot;, distance);
  Nan::SetPrototypeMethod(lcons, &quot;distanceAsync&quot;, distanceAsync);
  Nan::SetPrototypeMethod(lcons, &quot;convexHull&quot;, convexHull);
  Nan::SetPrototypeMethod(lcons, &quot;convexHullAsync&quot;, convexHullAsync);
  Nan::SetPrototypeMethod(lcons, &quot;buffer&quot;, buffer);
  Nan::SetPrototypeMethod(lcons, &quot;bufferAsync&quot;, bufferAsync);
  Nan::SetPrototypeMethod(lcons, &quot;intersection&quot;, intersection);
  Nan::SetPrototypeMethod(lcons, &quot;intersectionAsync&quot;, intersectionAsync);
  Nan::SetPrototypeMethod(lcons, &quot;union&quot;, unionGeometry);
  Nan::SetPrototypeMethod(lcons, &quot;unionAsync&quot;, unionGeometryAsync);
  Nan::SetPrototypeMethod(lcons, &quot;difference&quot;, difference);
  Nan::SetPrototypeMethod(lcons, &quot;differenceAsync&quot;, differenceAsync);
  Nan::SetPrototypeMethod(lcons, &quot;symDifference&quot;, symDifference);
  Nan::SetPrototypeMethod(lcons, &quot;symDifferenceAsync&quot;, symDifferenceAsync);
  Nan::SetPrototypeMethod(lcons, &quot;centroid&quot;, centroid);
  Nan::SetPrototypeMethod(lcons, &quot;centroidAsync&quot;, centroidAsync);
  Nan::SetPrototypeMethod(lcons, &quot;simplify&quot;, simplify);
  Nan::SetPrototypeMethod(lcons, &quot;simplifyAsync&quot;, simplifyAsync);
  Nan::SetPrototypeMethod(lcons, &quot;simplifyPreserveTopology&quot;, simplifyPreserveTopology);
  Nan::SetPrototypeMethod(lcons, &quot;simplifyPreserveTopologyAsync&quot;, simplifyPreserveTopologyAsync);
  Nan::SetPrototypeMethod(lcons, &quot;segmentize&quot;, segmentize);
  Nan::SetPrototypeMethod(lcons, &quot;swapXY&quot;, swapXY);
  Nan::SetPrototypeMethod(lcons, &quot;swapXYAsync&quot;, swapXYAsync);
  Nan::SetPrototypeMethod(lcons, &quot;getEnvelope&quot;, getEnvelope);
  Nan::SetPrototypeMethod(lcons, &quot;getEnvelopeAsync&quot;, getEnvelopeAsync);
  Nan::SetPrototypeMethod(lcons, &quot;getEnvelope3D&quot;, getEnvelope3D);
  Nan::SetPrototypeMethod(lcons, &quot;getEnvelope3DAsync&quot;, getEnvelope3DAsync);
  Nan::SetPrototypeMethod(lcons, &quot;transform&quot;, transform);
  Nan::SetPrototypeMethod(lcons, &quot;transformAsync&quot;, transformAsync);
  Nan::SetPrototypeMethod(lcons, &quot;transformTo&quot;, transformTo);
  Nan::SetPrototypeMethod(lcons, &quot;transformToAsync&quot;, transformToAsync);

  ATTR(lcons, &quot;srs&quot;, srsGetter, srsSetter);
  ATTR(lcons, &quot;wkbSize&quot;, wkbSizeGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;dimension&quot;, dimensionGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;coordinateDimension&quot;, coordinateDimensionGetter, coordinateDimensionSetter);
  ATTR(lcons, &quot;wkbType&quot;, typeGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;name&quot;, nameGetter, READ_ONLY_SETTER);

  Nan::Set(target, Nan::New(&quot;Geometry&quot;).ToLocalChecked(), Nan::GetFunction(lcons).ToLocalChecked());

  constructor.Reset(lcons);
}

Geometry::Geometry(OGRGeometry *geom) : Nan::ObjectWrap(), this_(geom), owned_(true), size_(0) {
  LOG(&quot;Created Geometry [%p]&quot;, geom);
  // The async locks must live outside the V8 memory management,
  // otherwise they won&#x27;t be accessible from the async threads
  async_lock = new uv_sem_t;
  uv_sem_init(async_lock, 1);
}

Geometry::Geometry() : Nan::ObjectWrap(), this_(NULL), owned_(true), size_(0) {
  async_lock = new uv_sem_t;
  uv_sem_init(async_lock, 1);
}

Geometry::~Geometry() {
  if (this_) {
    LOG(&quot;Disposing Geometry [%p] (%s)&quot;, this_, owned_ ? &quot;owned&quot; : &quot;unowned&quot;);
    if (owned_) {
      OGRGeometryFactory::destroyGeometry(this_);
      Nan::AdjustExternalMemory(-size_);
    }
    LOG(&quot;Disposed Geometry [%p]&quot;, this_)
    this_ = NULL;
  }
  uv_sem_destroy(async_lock);
  delete async_lock;
}

/**
 * Abstract base class for all geometry classes.
 *
 * @class gdal.Geometry
 */
NAN_METHOD(Geometry::New) {
  Nan::HandleScope scope;
  Geometry *f;

  if (!info.IsConstructCall()) {
    Nan::ThrowError(&quot;Cannot call constructor as function, you need to use &#x27;new&#x27; keyword&quot;);
    return;
  }

  if (info[0]-&gt;IsExternal()) {
    Local&lt;External&gt; ext = info[0].As&lt;External&gt;();
    void *ptr = ext-&gt;Value();
    f = static_cast&lt;Geometry *&gt;(ptr);

  } else {
    Nan::ThrowError(
      &quot;Geometry doesnt have a constructor, use Geometry.fromWKT(), Geometry.fromWKB() or type-specific constructor. ie. new ogr.Point()&quot;);
    return;
    // OGRwkbGeometryType geometry_type;
    // NODE_ARG_ENUM(0, &quot;geometry type&quot;, OGRwkbGeometryType, geometry_type);
    // OGRGeometry *geom = OGRGeometryFactory::createGeometry(geometry_type);
    // f = new Geometry(geom);
  }

  f-&gt;Wrap(info.This());
  info.GetReturnValue().Set(info.This());
}

Local&lt;Value&gt; Geometry::New(OGRGeometry *geom) {
  Nan::EscapableHandleScope scope;
  return scope.Escape(Geometry::New(geom, true));
}

Local&lt;Value&gt; Geometry::New(OGRGeometry *geom, bool owned) {
  Nan::EscapableHandleScope scope;

  if (!geom) { return scope.Escape(Nan::Null()); }

  OGRwkbGeometryType type = getGeometryType_fixed(geom);
  type = wkbFlatten(type);

  switch (type) {
    case wkbPoint: return scope.Escape(Point::New(static_cast&lt;OGRPoint *&gt;(geom), owned));
    case wkbLineString: return scope.Escape(LineString::New(static_cast&lt;OGRLineString *&gt;(geom), owned));
    case wkbLinearRing: return scope.Escape(LinearRing::New(static_cast&lt;OGRLinearRing *&gt;(geom), owned));
    case wkbPolygon: return scope.Escape(Polygon::New(static_cast&lt;OGRPolygon *&gt;(geom), owned));
    case wkbGeometryCollection:
      return scope.Escape(GeometryCollection::New(static_cast&lt;OGRGeometryCollection *&gt;(geom), owned));
    case wkbMultiPoint: return scope.Escape(MultiPoint::New(static_cast&lt;OGRMultiPoint *&gt;(geom), owned));
    case wkbMultiLineString: return scope.Escape(MultiLineString::New(static_cast&lt;OGRMultiLineString *&gt;(geom), owned));
    case wkbMultiPolygon: return scope.Escape(MultiPolygon::New(static_cast&lt;OGRMultiPolygon *&gt;(geom), owned));
    default: Nan::ThrowError(&quot;Tried to create unsupported geometry type&quot;); return scope.Escape(Nan::Undefined());
  }
}

OGRwkbGeometryType Geometry::getGeometryType_fixed(OGRGeometry *geom) {
  // For some reason OGRLinearRing::getGeometryType uses OGRLineString&#x27;s
  // method... meaning OGRLinearRing::getGeometryType returns wkbLineString

  // http://trac.osgeo.org/gdal/ticket/1755

  OGRwkbGeometryType type = geom-&gt;getGeometryType();

  if (std::string(geom-&gt;getGeometryName()) == &quot;LINEARRING&quot;) {
    type = (OGRwkbGeometryType)(wkbLinearRing | (type &amp; wkb25DBit));
  }

  return type;
}

NAN_METHOD(Geometry::toString) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  std::ostringstream ss;
  ss &lt;&lt; &quot;Geometry (&quot; &lt;&lt; geom-&gt;this_-&gt;getGeometryName() &lt;&lt; &quot;)&quot;;
  info.GetReturnValue().Set(Nan::New(ss.str().c_str()).ToLocalChecked());
}

/**
 * Closes any un-closed rings.
 *
 * @method closeRings
 */

/**
 * Closes any un-closed rings.
 * {{{async}}}
 *
 * @param {requestCallback} [callback] {{cb}}
 * @method closeRingsAsync
 */

NODE_WRAPPED_ASYNC_METHOD(Geometry, closeRings, closeRings);

/**
 * Clears the geometry.
 *
 * @method empty
 */

/**
 * Clears the geometry.
 * {{{async}}}
 *
 * @param {requestCallback} [callback] {{cb}}
 * @method emptyAsync
 */

NODE_WRAPPED_ASYNC_METHOD(Geometry, empty, empty);

/**
 * Swaps x, y coordinates.
 *
 * @method swapXY
 */

/**
 * Swaps x, y coordinates.
 * {{{async}}}
 *
 * @param {requestCallback} [callback] {{cb}}
 * @method swapXYAsync
 */

NODE_WRAPPED_ASYNC_METHOD(Geometry, swapXY, swapXY);

/**
 * Determines if the geometry is empty.
 *
 * @method isEmpty
 * @return Boolean
 */

/**
 * Determines if the geometry is empty.
 * {{{async}}}
 *
 * @method isEmptyAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT(Geometry, OGRBoolean, isEmpty, Boolean, IsEmpty);

/**
 * Determines if the geometry is valid.
 *
 * @method isValid
 * @return Boolean
 */

/**
 * Determines if the geometry is valid.
 * {{{async}}}
 *
 * @method isValidAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT(Geometry, OGRBoolean, isValid, Boolean, IsValid);

/**
 * Determines if the geometry is simple.
 *
 * @method isSimple
 * @return Boolean
 */

/**
 * Determines if the geometry is simple.
 * {{{async}}}
 *
 * @method isSimpleAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT(Geometry, OGRBoolean, isSimple, Boolean, IsSimple);

/**
 * Determines if the geometry is a ring.
 *
 * @method isRing
 * @return Boolean
 */

/**
 * Determines if the geometry is a ring.
 * {{{async}}}
 *
 * @method isRingAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT(Geometry, OGRBoolean, isRing, Boolean, IsRing);

/**
 * Determines if the two geometries intersect.
 *
 * @method intersects
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the two geometries intersect.
 * {{{async}}}
 *
 * @method intersectsAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, intersects, Boolean, Intersects, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the two geometries equal each other.
 *
 * @method equals
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the two geometries equal each other.
 * {{{async}}}
 *
 * @method equalsAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, equals, Boolean, Equals, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the two geometries are disjoint.
 *
 * @method disjoint
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the two geometries are disjoint.
 * {{{async}}}
 *
 * @method disjointAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, disjoint, Boolean, Disjoint, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the two geometries touch.
 *
 * @method touches
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the two geometries touch.
 * {{{async}}}
 *
 * @method touchesAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, touches, Boolean, Touches, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the two geometries cross.
 *
 * @method crosses
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the two geometries cross.
 * {{{async}}}
 *
 * @method crossesAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, crosses, Boolean, Crosses, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the current geometry is within the provided geometry.
 *
 * @method within
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the current geometry is within the provided geometry.
 * {{{async}}}
 *
 * @method withinAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, within, Boolean, Within, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the current geometry contains the provided geometry.
 *
 * @method contains
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the current geometry contains the provided geometry.
 * {{{async}}}
 *
 * @method containsAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, contains, Boolean, Contains, Geometry, &quot;geometry to compare&quot;);

/**
 * Determines if the current geometry overlaps the provided geometry.
 *
 * @method overlaps
 * @param {gdal.Geometry} geometry
 * @return Boolean
 */

/**
 * Determines if the current geometry overlaps the provided geometry.
 * {{{async}}}
 *
 * @method overlapsAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Boolean
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, OGRBoolean, overlaps, Boolean, Overlaps, Geometry, &quot;geometry to compare&quot;);

/**
 * Computes the distance between the two geometries.
 *
 * @method distance
 * @param {gdal.Geometry} geometry
 * @return Number
 */

/**
 * Computes the distance between the two geometries.
 * {{{async}}}
 *
 * @method distanceAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return Number
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_RESULT_1_WRAPPED_PARAM(
  Geometry, double, distance, Number, Distance, Geometry, &quot;geometry to use for distance calculation&quot;);

/**
 * Modify the geometry such it has no segment longer then the given distance.
 *
 * @method segmentize
 * @param {Number} segment_length
 * @return Number
 */
NODE_WRAPPED_METHOD_WITH_1_DOUBLE_PARAM(Geometry, segmentize, segmentize, &quot;segment length&quot;);

/**
 * Apply arbitrary coordinate transformation to the geometry.
 *
 * This method will transform the coordinates of a geometry from their current
 * spatial reference system to a new target spatial reference system. Normally
 * this means reprojecting the vectors, but it could include datum shifts,
 * and changes of units.
 *
 * Note that this method does not require that the geometry already have a
 * spatial reference system. It will be assumed that they can be treated as
 * having the source spatial reference system of the {{#crossLink
 * &quot;gdal.CoordinateTransformation&quot;}}CoordinateTransformation{{/crossLink}}
 * object, and the actual SRS of the geometry will be ignored.
 *
 * @throws Error
 * @method transform
 * @param {gdal.CoordinateTransformation} transformation
 */

/**
 * Apply arbitrary coordinate transformation to the geometry.
 * {{{async}}}
 *
 * @throws Error
 * @method transformAsync
 * @param {requestCallback} [callback] {{cb}}
 * @param {gdal.CoordinateTransformation} transformation
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_OGRERR_RESULT_1_WRAPPED_PARAM(
  Geometry, int, transform, transform, CoordinateTransformation, &quot;transform&quot;);

/**
 * Transforms the geometry to match the provided {{#crossLink
 * &quot;gdal.SpatialReference&quot;}}SpatialReference{{/crossLink}}.
 *
 * @throws Error
 * @method transformTo
 * @param {gdal.SpatialReference} srs
 */

/**
 * Transforms the geometry to match the provided {{#crossLink
 * &quot;gdal.SpatialReference&quot;}}SpatialReference{{/crossLink}}.
 * {{{async}}}
 *
 * @throws Error
 * @method transformToAsync
 * @param {requestCallback} [callback] {{cb}}
 * @param {gdal.SpatialReference} srs
 */

NODE_WRAPPED_ASYNC_METHOD_WITH_OGRERR_RESULT_1_WRAPPED_PARAM(
  Geometry, int, transformTo, transformTo, SpatialReference, &quot;spatial reference&quot;);

/**
 * Clones the instance.
 *
 * @method clone
 * @return gdal.Geometry
 */
NAN_METHOD(Geometry::clone) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(Geometry::New(geom-&gt;this_-&gt;clone()));
}

/**
 * Compute convex hull.
 *
 * @method convexHull
 * @return gdal.Geometry
 */

/**
 * Compute convex hull.
 * {{{async}}}
 *
 * @method convexHullAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::convexHull) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  OGRGeometry *gdal_geom = geom-&gt;this_;
  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom]() { return gdal_geom-&gt;ConvexHull(); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 0);
}

/**
 * Compute boundary.
 *
 * @method boundary
 * @return gdal.Geometry
 */

/**
 * Compute boundary.
 * {{{async}}}
 *
 * @method boundaryAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::boundary) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  OGRGeometry *gdal_geom = geom-&gt;this_;
  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom]() { return gdal_geom-&gt;Boundary(); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 0);
}

/**
 * Compute intersection with another geometry.
 *
 * @method intersection
 * @param {gdal.Geometry} geometry
 * @return gdal.Geometry
 */

/**
 * Compute intersection with another geometry.
 * {{{async}}}
 *
 * @method intersectionAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::intersection) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  Geometry *x = NULL;

  NODE_ARG_WRAPPED(0, &quot;geometry to use for intersection&quot;, Geometry, x);

  OGRGeometry *gdal_geom = geom-&gt;this_;
  OGRGeometry *gdal_x = x-&gt;this_;
  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, gdal_x]() { return gdal_geom-&gt;Intersection(gdal_x); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 1);
}

/**
 * Compute the union of this geometry with another.
 *
 * @method union
 * @param {gdal.Geometry} geometry
 * @return gdal.Geometry
 */

/**
 * Compute the union of this geometry with another.
 * {{{async}}}
 *
 * @method unionAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::unionGeometry) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  Geometry *x = NULL;

  NODE_ARG_WRAPPED(0, &quot;geometry to use for union&quot;, Geometry, x);

  OGRGeometry *gdal_geom = geom-&gt;this_;
  OGRGeometry *gdal_x = x-&gt;this_;
  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, gdal_x]() { return gdal_geom-&gt;Union(gdal_x); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 1);
}

/**
 * Compute the difference of this geometry with another.
 *
 * @method difference
 * @param {gdal.Geometry} geometry
 * @return gdal.Geometry
 */

/**
 * Compute the difference of this geometry with another.
 * {{{async}}}
 *
 * @method differenceAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::difference) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  Geometry *x = NULL;

  NODE_ARG_WRAPPED(0, &quot;geometry to use for difference&quot;, Geometry, x);

  OGRGeometry *gdal_geom = geom-&gt;this_;
  OGRGeometry *gdal_x = x-&gt;this_;
  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, gdal_x]() { return gdal_geom-&gt;Difference(gdal_x); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 1);
}

/**
 * Computes the symmetric difference of this geometry and the second geometry.
 *
 * @method symDifference
 * @param {gdal.Geometry} geometry
 * @return gdal.Geometry
 */

/**
 * Computes the symmetric difference of this geometry and the second geometry.
 * {{{async}}}
 *
 * @method symDifferenceAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::symDifference) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  Geometry *x = NULL;

  NODE_ARG_WRAPPED(0, &quot;geometry to use for symDifference&quot;, Geometry, x);

  OGRGeometry *gdal_geom = geom-&gt;this_;
  OGRGeometry *gdal_x = x-&gt;this_;
  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, gdal_x]() { return gdal_geom-&gt;SymDifference(gdal_x); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 1);
}

/**
 * Reduces the geometry complexity.
 *
 * @method simplify
 * @param {Number} tolerance
 * @return gdal.Geometry
 */

/**
 * Reduces the geometry complexity.
 * {{{async}}}
 *
 * @method simplifyAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::simplify) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  double tolerance;

  NODE_ARG_DOUBLE(0, &quot;tolerance&quot;, tolerance);
  OGRGeometry *gdal_geom = geom-&gt;this_;

  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, tolerance]() { return gdal_geom-&gt;Simplify(tolerance); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 1);
}

/**
 * Reduces the geometry complexity while preserving the topology.
 *
 * @method simplifyPreserveTopology
 * @param {Number} tolerance
 * @return gdal.Geometry
 */

/**
 * Reduces the geometry complexity while preserving the topology.
 * {{{async}}}
 *
 * @method simplifyPreserveTopologyAsync
 * @param {gdal.Geometry} geometry
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::simplifyPreserveTopology) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  double tolerance;

  NODE_ARG_DOUBLE(0, &quot;tolerance&quot;, tolerance);
  OGRGeometry *gdal_geom = geom-&gt;this_;

  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, tolerance]() { return gdal_geom-&gt;SimplifyPreserveTopology(tolerance); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 1);
}

/**
 * Buffers the geometry by the given distance.
 *
 * @method buffer
 * @param {Number} distance
 * @param {integer} segments
 * @return gdal.Geometry
 */

/**
 * Buffers the geometry by the given distance.
 * {{{async}}}
 *
 * @method bufferAsync
 * @param {Number} distance
 * @param {integer} segments
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::buffer) {
  Nan::HandleScope scope;

  double distance;
  int number_of_segments = 30;

  NODE_ARG_DOUBLE(0, &quot;distance&quot;, distance);
  NODE_ARG_INT_OPT(1, &quot;number of segments&quot;, number_of_segments);

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;

  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.persist(info.This());
  job.main = [gdal_geom, distance, number_of_segments]() { return gdal_geom-&gt;Buffer(distance, number_of_segments); };
  job.rval = [](OGRGeometry *r, GDAL_ASYNCABLE_OBJS) { return Geometry::New(r); };
  job.run(info, async, 2);
}

/**
 * Convert a geometry into well known text format.
 *
 * @method toWKT
 * @return gdal.Geometry
 */

/**
 * Convert a geometry into well known text format.
 * {{{async}}}
 *
 * @method toWKTAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::exportToWKT) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;
  GDALAsyncableJob&lt;char *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    char *text = NULL;
    uv_sem_wait(async_lock);
    OGRErr err = gdal_geom-&gt;exportToWkt(&amp;text);
    uv_sem_post(async_lock);
    if (err) { throw getOGRErrMsg(err); }
    return text;
  };

  job.rval = [](char *text, GDAL_ASYNCABLE_OBJS) {
    if (text) { return SafeString::New(text); }
    return Nan::Undefined().As&lt;Value&gt;();
  };

  job.run(info, async, 0);
}

/**
 * Convert a geometry into well known binary format.
 *
 * @method toWKB
 * @param {string} [byte_order=&quot;MSB&quot;] ({{#crossLink &quot;Constants
 * (wkbByteOrder)&quot;}}see options{{/crossLink}})
 * @param {string} [variant=&quot;OGC&quot;] ({{#crossLink &quot;Constants (wkbVariant)&quot;}}see
 * options{{/crossLink}})
 * @return gdal.Geometry
 */

/**
 * Convert a geometry into well known binary format.
 * {{{async}}}
 *
 * @method toWKBAsync
 * @param {string} [byte_order=&quot;MSB&quot;] ({{#crossLink &quot;Constants
 * (wkbByteOrder)&quot;}}see options{{/crossLink}})
 * @param {string} [variant=&quot;OGC&quot;] ({{#crossLink &quot;Constants (wkbVariant)&quot;}}see
 * options{{/crossLink}})
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::exportToWKB) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  int size = geom-&gt;this_-&gt;WkbSize();
  unsigned char *data = (unsigned char *)malloc(size);

  // byte order
  OGRwkbByteOrder byte_order;
  std::string order = &quot;MSB&quot;;
  NODE_ARG_OPT_STR(0, &quot;byte order&quot;, order);
  if (order == &quot;MSB&quot;) {
    byte_order = wkbXDR;
  } else if (order == &quot;LSB&quot;) {
    byte_order = wkbNDR;
  } else {
    Nan::ThrowError(&quot;byte order must be &#x27;MSB&#x27; or &#x27;LSB&#x27;&quot;);
    return;
  }

#if GDAL_VERSION_MAJOR &gt; 1 || (GDAL_VERSION_MINOR &gt; 10)
  // wkb variant
  OGRwkbVariant wkb_variant;
  std::string variant = &quot;OGC&quot;;
  NODE_ARG_OPT_STR(1, &quot;wkb variant&quot;, variant);
  if (variant == &quot;OGC&quot;) {
#if GDAL_VERSION_MAJOR &gt; 1
    wkb_variant = wkbVariantOldOgc;
#else
    wkb_variant = wkbVariantOgc;
#endif
  } else if (variant == &quot;ISO&quot;) {
    wkb_variant = wkbVariantIso;
  } else {
    Nan::ThrowError(&quot;variant must be &#x27;OGC&#x27; or &#x27;ISO&#x27;&quot;);
    return;
  }
  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;
  GDALAsyncableJob&lt;unsigned char *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom, data, byte_order, wkb_variant]() {
    uv_sem_wait(async_lock);
    OGRErr err = gdal_geom-&gt;exportToWkb(byte_order, data, wkb_variant);
    uv_sem_post(async_lock);
    if (err) {
      free(data);
      throw getOGRErrMsg(err);
    }
    return data;
  };
  //^^ export to wkb and fill buffer ^^
  job.rval = [size](unsigned char *data, GDAL_ASYNCABLE_OBJS) {
    Local&lt;Value&gt; result = Nan::NewBuffer((char *)data, size).ToLocalChecked();
    return result;
  };
  job.run(info, async, 2);
#else
  GDAL_ASYNCABLE_1x_UNSUPPORTED;
  OGRErr err = geom-&gt;this_-&gt;exportToWkb(byte_order, data);
  if (err) {
    free(data);
    NODE_THROW_OGRERR(err);
    return;
  }
  //^^ export to wkb and fill buffer ^^
  Local&lt;Value&gt; result = Nan::NewBuffer((char *)data, size).ToLocalChecked();
  info.GetReturnValue().Set(result);
#endif
}

/**
 * Convert a geometry into KML format.
 *
 * @method toKML
 * @return gdal.Geometry
 */

/**
 * Convert a geometry into KML format.
 * {{{async}}}
 *
 * @method toKMLAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::exportToKML) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;
  GDALAsyncableJob&lt;char *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    uv_sem_wait(async_lock);
    char *text = gdal_geom-&gt;exportToKML();
    uv_sem_post(async_lock);
    return text;
  };
  job.rval = [](char *text, GDAL_ASYNCABLE_OBJS) {
    if (text) {
      Local&lt;Value&gt; result = Nan::New(text).ToLocalChecked();
      CPLFree(text);
      return result;
    }
    return Nan::Undefined().As&lt;Value&gt;();
  };
  job.run(info, async, 0);
}

/**
 * Convert a geometry into GML format.
 *
 * @method toGML
 * @return gdal.Geometry
 */

/**
 * Convert a geometry into GML format.
 * {{{async}}}
 *
 * @method toGMLAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::exportToGML) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;
  GDALAsyncableJob&lt;char *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    uv_sem_wait(async_lock);
    char *text = gdal_geom-&gt;exportToGML();
    uv_sem_post(async_lock);
    return text;
  };
  job.rval = [](char *text, GDAL_ASYNCABLE_OBJS) {
    if (text) {
      Local&lt;Value&gt; result = Nan::New(text).ToLocalChecked();
      CPLFree(text);
      return result;
    }
    return Nan::Undefined().As&lt;Value&gt;();
  };
  job.run(info, async, 0);
}

/**
 * Convert a geometry into JSON format.
 *
 * @method toJSON
 * @return gdal.Geometry
 */

/**
 * Convert a geometry into JSON format.
 * {{{async}}}
 *
 * @method toJSONAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::exportToJSON) {
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;
  GDALAsyncableJob&lt;char *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    uv_sem_wait(async_lock);
    char *text = gdal_geom-&gt;exportToJson();
    uv_sem_post(async_lock);
    return text;
  };
  job.rval = [](char *text, GDAL_ASYNCABLE_OBJS) {
    if (text) {
      Local&lt;Value&gt; result = Nan::New(text).ToLocalChecked();
      CPLFree(text);
      return result;
    }
    return Nan::Undefined().As&lt;Value&gt;();
  };
  job.run(info, async, 0);
}

/**
 * Compute the centroid of the geometry.
 *
 * @method centroid
 * @return gdal.Point
 */

/**
 * Compute the centroid of the geometry.
 * {{{async}}}
 *
 * @method centroidAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Point
 */

GDAL_ASYNCABLE_DEFINE(Geometry::centroid) {
  // The Centroid method wants the caller to create the point to fill in.
  // Instead of requiring the caller to create the point geometry to fill in, we
  // new up an OGRPoint and put the result into it and return that.
  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;
  GDALAsyncableJob&lt;OGRPoint *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    OGRPoint *point = new OGRPoint();
    uv_sem_wait(async_lock);
    OGRErr err = gdal_geom-&gt;Centroid(point);
    uv_sem_post(async_lock);
    if (err) {
      delete point;
      throw getOGRErrMsg(err);
    }
    return point;
  };
  job.rval = [](OGRPoint *point, GDAL_ASYNCABLE_OBJS) { return Point::New(point); };
  job.run(info, async, 0);
}

/**
 * Computes the bounding box (envelope).
 *
 * @method getEnvelope
 * @return {gdal.Envelope} Bounding envelope
 */

/**
 * Computes the bounding box (envelope).
 * {{{async}}}
 *
 * @method getEnvelopeAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return {gdal.Envelope} Bounding envelope
 */
GDAL_ASYNCABLE_DEFINE(Geometry::getEnvelope) {
  // returns object containing boundaries until complete OGREnvelope binding is
  // built

  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;

  GDALAsyncableJob&lt;OGREnvelope *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    OGREnvelope *envelope = new OGREnvelope();
    uv_sem_wait(async_lock);
    gdal_geom-&gt;getEnvelope(envelope);
    uv_sem_post(async_lock);
    return envelope;
  };

  job.rval = [](OGREnvelope *envelope, GDAL_ASYNCABLE_OBJS) {
    Local&lt;Object&gt; obj = Nan::New&lt;Object&gt;();
    Nan::Set(obj, Nan::New(&quot;minX&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MinX));
    Nan::Set(obj, Nan::New(&quot;maxX&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MaxX));
    Nan::Set(obj, Nan::New(&quot;minY&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MinY));
    Nan::Set(obj, Nan::New(&quot;maxY&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MaxY));
    delete envelope;
    return obj;
  };
  job.run(info, async, 0);
}

/**
 * Computes the 3D bounding box (envelope).
 *
 * @method getEnvelope3D
 * @return {gdal.Envelope3D} Bounding envelope
 */

/**
 * Computes the 3D bounding box (envelope).
 * {{{async}}}
 *
 * @method getEnvelope3DAsync
 * @param {requestCallback} [callback] {{cb}}
 * @return {gdal.Envelope3D} Bounding envelope
 */

GDAL_ASYNCABLE_DEFINE(Geometry::getEnvelope3D) {
  // returns object containing boundaries until complete OGREnvelope binding is
  // built

  Nan::HandleScope scope;

  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRGeometry *gdal_geom = geom-&gt;this_;
  uv_sem_t *async_lock = geom-&gt;async_lock;

  GDALAsyncableJob&lt;OGREnvelope3D *&gt; job;
  job.persist(info.This());
  job.main = [async_lock, gdal_geom]() {
    OGREnvelope3D *envelope = new OGREnvelope3D();
    uv_sem_wait(async_lock);
    gdal_geom-&gt;getEnvelope(envelope);
    uv_sem_post(async_lock);
    return envelope;
  };

  job.rval = [](OGREnvelope3D *envelope, GDAL_ASYNCABLE_OBJS) {
    Local&lt;Object&gt; obj = Nan::New&lt;Object&gt;();
    Nan::Set(obj, Nan::New(&quot;minX&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MinX));
    Nan::Set(obj, Nan::New(&quot;maxX&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MaxX));
    Nan::Set(obj, Nan::New(&quot;minY&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MinY));
    Nan::Set(obj, Nan::New(&quot;maxY&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MaxY));
    Nan::Set(obj, Nan::New(&quot;minZ&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MinZ));
    Nan::Set(obj, Nan::New(&quot;maxZ&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(envelope-&gt;MaxZ));
    delete envelope;
    return obj;
  };
  job.run(info, async, 0);
}

// --- JS static methods (OGRGeometryFactory) ---

/**
 * Creates a Geometry from a WKT string.
 *
 * @static
 * @method fromWKT
 * @param {String} wkt
 * @param {gdal.SpatialReference} [srs]
 * @return gdal.Geometry
 */

/**
 * Creates a Geometry from a WKT string.
 * {{{async}}}
 *
 * @static
 * @method fromWKTAsync
 * @param {String} wkt
 * @param {gdal.SpatialReference} [srs]
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::createFromWkt) {
  Nan::HandleScope scope;

  std::string *wkt_string = new std::string;
  SpatialReference *srs = NULL;

  NODE_ARG_STR(0, &quot;wkt&quot;, *wkt_string);
  NODE_ARG_WRAPPED_OPT(1, &quot;srs&quot;, SpatialReference, srs);

  OGRSpatialReference *ogr_srs = NULL;
  if (srs) { ogr_srs = srs-&gt;get(); }

  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.main = [wkt_string, ogr_srs]() {
    std::unique_ptr&lt;std::string&gt; wkt_string_ptr(wkt_string);
    OGRGeometry *geom = NULL;
    OGRChar *wkt = (OGRChar *)wkt_string-&gt;c_str();
    OGRErr err = OGRGeometryFactory::createFromWkt(wkt, ogr_srs, &amp;geom);
    if (err) throw getOGRErrMsg(err);
    return geom;
  };
  job.rval = [](OGRGeometry *geom, GDAL_ASYNCABLE_OBJS) { return Geometry::New(geom, true); };
  job.run(info, async, 2);
}

/**
 * Creates a Geometry from a WKB buffer.
 *
 * @static
 * @method fromWKB
 * @param {Buffer} wkb
 * @param {gdal.SpatialReference} [srs]
 * @return gdal.Geometry
 */

/**
 * Creates a Geometry from a WKB buffer.
 * {{{async}}}
 *
 * @static
 * @method fromWKBAsync
 * @param {Buffer} wkb
 * @param {gdal.SpatialReference} [srs]
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */

GDAL_ASYNCABLE_DEFINE(Geometry::createFromWkb) {
  Nan::HandleScope scope;

  std::string wkb_string;
  SpatialReference *srs = NULL;

  Local&lt;Object&gt; wkb_obj;
  NODE_ARG_OBJECT(0, &quot;wkb&quot;, wkb_obj);
  NODE_ARG_WRAPPED_OPT(1, &quot;srs&quot;, SpatialReference, srs);

  std::string obj_type = *Nan::Utf8String(wkb_obj-&gt;GetConstructorName());

  if (obj_type != &quot;Buffer&quot; &amp;&amp; obj_type != &quot;Uint8Array&quot;) {
    Nan::ThrowError(&quot;Argument must be a buffer object&quot;);
    return;
  }

  unsigned char *data = (unsigned char *)Buffer::Data(wkb_obj);
  size_t length = Buffer::Length(wkb_obj);

  OGRSpatialReference *ogr_srs = NULL;
  if (srs) { ogr_srs = srs-&gt;get(); }

  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.main = [data, length, ogr_srs]() {
    OGRGeometry *geom = NULL;
    OGRErr err = OGRGeometryFactory::createFromWkb(data, ogr_srs, &amp;geom, length);
    if (err) throw getOGRErrMsg(err);
    return geom;
  };
  job.rval = [](OGRGeometry *geom, GDAL_ASYNCABLE_OBJS) { return Geometry::New(geom, true); };
  job.run(info, async, 2);
}

/**
 * Creates a Geometry from a GeoJSON string.
 *
 * @static
 * @method fromGeoJson
 * @param {Object} geojson
 * @return gdal.Geometry
 */

/**
 * Creates a Geometry from a GeoJSON string.
 * {{{async}}}
 *
 * Alas, the current implementation uses V8&#x27;s JSON.Stringify
 * and then converts the string to UTF-8 (from JS internal UTF-16)
 * This part is neither async-compatible, neither parallelizable
 * The GDAL part is async
 * Pay attention to the event loop if you use this and need
 * to remain low-latency
 *
 * @static
 * @method fromGeoJsonAsync
 * @param {Object} geojson
 * @param {requestCallback} [callback] {{cb}}
 * @return gdal.Geometry
 */
GDAL_ASYNCABLE_DEFINE(Geometry::createFromGeoJson) {
  Nan::HandleScope scope;
#if GDAL_VERSION_MAJOR &lt; 2 || (GDAL_VERSION_MAJOR &lt;= 2 &amp;&amp; GDAL_VERSION_MINOR &lt; 3)
  Nan::ThrowError(&quot;GDAL &lt; 2.3 does not support parsing GeoJSON directly&quot;);
  return;
#else

  Local&lt;Object&gt; geo_obj;
  NODE_ARG_OBJECT(0, &quot;geojson&quot;, geo_obj);

  // goes to text to pass it in, there isn&#x27;t a performant way to
  // go from v8 JSON -&gt; CPLJSON anyways
  Nan::JSON NanJSON;
  Nan::MaybeLocal&lt;String&gt; result = NanJSON.Stringify(geo_obj);
  if (result.IsEmpty()) {
    Nan::ThrowError(&quot;Invalid GeoJSON&quot;);
    return;
  }
  Local&lt;String&gt; stringified = result.ToLocalChecked();
  std::string *val = new std::string(*Nan::Utf8String(stringified));
  OGRGeometry *geom = NULL;
  OGRSpatialReference *ogr_srs = NULL;

  GDALAsyncableJob&lt;OGRGeometry *&gt; job;
  job.main = [val, geom, ogr_srs]() {
    std::unique_ptr&lt;std::string&gt; val_ptr(val);
    OGRGeometry *geom = OGRGeometryFactory::createFromGeoJson(val-&gt;c_str());
    return geom;
  };
  job.rval = [](OGRGeometry *geom, GDAL_ASYNCABLE_OBJS) { return Geometry::New(geom, true); };
  job.run(info, async, 1);
#endif
}

/**
 * Creates an empty Geometry from a WKB type.
 *
 * @static
 * @method create
 * @param {Integer} type WKB geometry type ({{#crossLink &quot;Constants
 * (wkbGeometryType)&quot;}}available options{{/crossLink}})
 * @return gdal.Geometry
 */
NAN_METHOD(Geometry::create) {
  Nan::HandleScope scope;

  OGRwkbGeometryType type = wkbUnknown;
  NODE_ARG_ENUM(0, &quot;type&quot;, OGRwkbGeometryType, type);

  info.GetReturnValue().Set(Geometry::New(OGRGeometryFactory::createGeometry(type), true));
}

/**
 * @attribute srs
 * @type gdal.SpatialReference
 */
NAN_GETTER(Geometry::srsGetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(SpatialReference::New(geom-&gt;this_-&gt;getSpatialReference(), false));
}

NAN_SETTER(Geometry::srsSetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  OGRSpatialReference *srs = NULL;
  if (IS_WRAPPED(value, SpatialReference)) {
    SpatialReference *srs_obj = Nan::ObjectWrap::Unwrap&lt;SpatialReference&gt;(value.As&lt;Object&gt;());
    srs = srs_obj-&gt;get();
  } else if (!value-&gt;IsNull() &amp;&amp; !value-&gt;IsUndefined()) {
    Nan::ThrowError(&quot;srs must be SpatialReference object&quot;);
    return;
  }

  geom-&gt;this_-&gt;assignSpatialReference(srs);
}

/**
 * @readOnly
 * @attribute name
 * @type String
 */
NAN_GETTER(Geometry::nameGetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(SafeString::New(geom-&gt;this_-&gt;getGeometryName()));
}

/**
 * See {{#crossLink &quot;Constants
 * (wkbGeometryType)&quot;}}wkbGeometryTypes{{/crossLink}}.
 * @readOnly
 * @attribute wkbType
 * @type integer
 */
NAN_GETTER(Geometry::typeGetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(Nan::New&lt;Integer&gt;(getGeometryType_fixed(geom-&gt;this_)));
}

/**
 * @readOnly
 * @attribute wkbSize
 * @type Integer
 */
NAN_GETTER(Geometry::wkbSizeGetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(Nan::New&lt;Integer&gt;(geom-&gt;this_-&gt;WkbSize()));
}

/**
 * @readOnly
 * @attribute dimension
 * @type Integer
 */
NAN_GETTER(Geometry::dimensionGetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(Nan::New&lt;Integer&gt;(geom-&gt;this_-&gt;getDimension()));
}

/**
 * @attribute coordinateDimension
 * @type Integer
 */
NAN_GETTER(Geometry::coordinateDimensionGetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());
  info.GetReturnValue().Set(Nan::New&lt;Integer&gt;(geom-&gt;this_-&gt;getCoordinateDimension()));
}

NAN_SETTER(Geometry::coordinateDimensionSetter) {
  Nan::HandleScope scope;
  Geometry *geom = Nan::ObjectWrap::Unwrap&lt;Geometry&gt;(info.This());

  if (!value-&gt;IsInt32()) {
    Nan::ThrowError(&quot;coordinateDimension must be an integer&quot;);
    return;
  }
  int dim = Nan::To&lt;int64_t&gt;(value).ToChecked();
  if (dim != 2 &amp;&amp; dim != 3) {
    Nan::ThrowError(&quot;coordinateDimension must be 2 or 3&quot;);
    return;
  }

  geom-&gt;this_-&gt;setCoordinateDimension(dim);
}

Local&lt;Value&gt; Geometry::getConstructor(OGRwkbGeometryType type) {
  Nan::EscapableHandleScope scope;

  type = wkbFlatten(type);
  switch (type) {
    case wkbPoint: return scope.Escape(Nan::GetFunction(Nan::New(Point::constructor)).ToLocalChecked());
    case wkbLineString: return scope.Escape(Nan::GetFunction(Nan::New(LineString::constructor)).ToLocalChecked());
    case wkbLinearRing: return scope.Escape(Nan::GetFunction(Nan::New(LinearRing::constructor)).ToLocalChecked());
    case wkbPolygon: return scope.Escape(Nan::GetFunction(Nan::New(Polygon::constructor)).ToLocalChecked());
    case wkbGeometryCollection:
      return scope.Escape(Nan::GetFunction(Nan::New(GeometryCollection::constructor)).ToLocalChecked());
    case wkbMultiPoint: return scope.Escape(Nan::GetFunction(Nan::New(MultiPoint::constructor)).ToLocalChecked());
    case wkbMultiLineString:
      return scope.Escape(Nan::GetFunction(Nan::New(MultiLineString::constructor)).ToLocalChecked());
    case wkbMultiPolygon: return scope.Escape(Nan::GetFunction(Nan::New(MultiPolygon::constructor)).ToLocalChecked());
    default: return scope.Escape(Nan::Null());
  }
}

/**
 * Returns the Geometry subclass that matches the
 * given WKB geometry type.
 *
 * @static
 * @method getConstructor
 * @param {Integer} type WKB geometry type ({{#crossLink &quot;Constants
 * (wkbGeometryType)&quot;}}available options{{/crossLink}})
 * @return Function
 */
NAN_METHOD(Geometry::getConstructor) {
  Nan::HandleScope scope;
  OGRwkbGeometryType type;
  NODE_ARG_ENUM(0, &quot;wkbType&quot;, OGRwkbGeometryType, type);
  info.GetReturnValue().Set(getConstructor(type));
}

/**
 * Returns the Geometry subclass name that matches the
 * given WKB geometry type.
 *
 * @static
 * @method getName
 * @param {Integer} type WKB geometry type ({{#crossLink &quot;Constants
 * (wkbGeometryType)&quot;}}available options{{/crossLink}})
 * @return String
 */
NAN_METHOD(Geometry::getName) {
  Nan::HandleScope scope;
  OGRwkbGeometryType type;
  NODE_ARG_ENUM(0, &quot;wkbType&quot;, OGRwkbGeometryType, type);
  info.GetReturnValue().Set(SafeString::New(OGRGeometryTypeToName(type)));
}

} // namespace node_gdal

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
