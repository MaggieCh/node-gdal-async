<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/gdal_algorithms.cpp - node-gdal-async</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-async" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-async">
            node-gdal-async
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>3.3.4</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DIM)", "classes/Constants (DIR)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.ArrayAttributes", "classes/gdal.ArrayDimensions", "classes/gdal.Attribute", "classes/gdal.CircularString", "classes/gdal.CompoundCurve", "classes/gdal.CompoundCurveCurves", "classes/gdal.config", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Dimension", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Group", "classes/gdal.GroupArrays", "classes/gdal.GroupAttributes", "classes/gdal.GroupDimensions", "classes/gdal.GroupGroups", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MDArray", "classes/gdal.MultiCurve", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.SimpleCurve", "classes/gdal.SpatialReference", "classes/vsimem
Operations on in-memory /vsimem/ files"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DIM).html">Constants (DIM)</a></li>
                <li><a href="../classes/Constants (DIR).html">Constants (DIR)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.ArrayAttributes.html">gdal.ArrayAttributes</a></li>
                <li><a href="../classes/gdal.ArrayDimensions.html">gdal.ArrayDimensions</a></li>
                <li><a href="../classes/gdal.Attribute.html">gdal.Attribute</a></li>
                <li><a href="../classes/gdal.CircularString.html">gdal.CircularString</a></li>
                <li><a href="../classes/gdal.CompoundCurve.html">gdal.CompoundCurve</a></li>
                <li><a href="../classes/gdal.CompoundCurveCurves.html">gdal.CompoundCurveCurves</a></li>
                <li><a href="../classes/gdal.config.html">gdal.config</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Dimension.html">gdal.Dimension</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Group.html">gdal.Group</a></li>
                <li><a href="../classes/gdal.GroupArrays.html">gdal.GroupArrays</a></li>
                <li><a href="../classes/gdal.GroupAttributes.html">gdal.GroupAttributes</a></li>
                <li><a href="../classes/gdal.GroupDimensions.html">gdal.GroupDimensions</a></li>
                <li><a href="../classes/gdal.GroupGroups.html">gdal.GroupGroups</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MDArray.html">gdal.MDArray</a></li>
                <li><a href="../classes/gdal.MultiCurve.html">gdal.MultiCurve</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.SimpleCurve.html">gdal.SimpleCurve</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
                <li><a href="../classes/vsimem
Operations on in-memory /vsimem/ files.html">vsimem
Operations on in-memory /vsimem/ files</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/gdal_algorithms.cpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
#include &quot;gdal_algorithms.hpp&quot;
#include &quot;gdal_common.hpp&quot;
#include &quot;gdal_dataset.hpp&quot;
#include &quot;gdal_layer.hpp&quot;
#include &quot;gdal_rasterband.hpp&quot;
#include &quot;utils/number_list.hpp&quot;

namespace node_gdal {

void Algorithms::Initialize(Local&lt;Object&gt; target) {
  Nan__SetAsyncableMethod(target, &quot;fillNodata&quot;, fillNodata);
  Nan__SetAsyncableMethod(target, &quot;contourGenerate&quot;, contourGenerate);
  Nan__SetAsyncableMethod(target, &quot;sieveFilter&quot;, sieveFilter);
  Nan__SetAsyncableMethod(target, &quot;checksumImage&quot;, checksumImage);
  Nan__SetAsyncableMethod(target, &quot;polygonize&quot;, polygonize);
  Nan__SetAsyncableMethod(target, &quot;_acquireLocks&quot;, _acquireLocks);
}

/**
 * @typedef FillOptions { src: gdal.RasterBand, mask?: gdal.RasterBand, searchDist: number, smoothingIterations?: number }
 */

/**
 * Fill raster regions by interpolation from edges.
 *
 * @throws Error
 * @method fillNodata
 * @static
 * @for gdal
 * @param {FillOptions} options
 * @param {gdal.RasterBand} options.src This band to be updated in-place.
 * @param {gdal.RasterBand} [options.mask] Mask band
 * @param {number} options.searchDist The maximum distance (in pixels) that the algorithm will search out for values to interpolate.
 * @param {number} [options.smoothingIterations=0] The number of 3x3 average filter smoothing iterations to run after the interpolation to dampen artifacts.
 */

/**
 * Fill raster regions by interpolation from edges.
 * {{{async}}}
 *
 * @throws Error
 * @method fillNodataAsync
 * @static
 * @for gdal
 * @param {FillOptions} options
 * @param {gdal.RasterBand} options.src This band to be updated in-place.
 * @param {gdal.RasterBand} [options.mask] Mask band
 * @param {number} options.searchDist The maximum distance (in pixels) that the algorithm will search out for values to interpolate.
 * @param {number} [options.smoothingIterations=0] The number of 3x3 average filter smoothing iterations to run after the interpolation to dampen artifacts.
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */

GDAL_ASYNCABLE_DEFINE(Algorithms::fillNodata) {
  Nan::HandleScope scope;

  Local&lt;Object&gt; obj;
  RasterBand *src;
  RasterBand *mask = NULL;
  double search_dist;
  int smooth_iterations = 0;

  NODE_ARG_OBJECT(0, &quot;options&quot;, obj);

  NODE_WRAPPED_FROM_OBJ(obj, &quot;src&quot;, RasterBand, src);
  NODE_WRAPPED_FROM_OBJ_OPT(obj, &quot;mask&quot;, RasterBand, mask);
  NODE_DOUBLE_FROM_OBJ(obj, &quot;searchDist&quot;, search_dist);
  NODE_INT_FROM_OBJ_OPT(obj, &quot;smoothIterations&quot;, smooth_iterations);

  GDALRasterBand *gdal_src = src-&gt;get();
  GDALRasterBand *gdal_mask = mask ? mask-&gt;get() : nullptr;

  std::vector&lt;long&gt; ds_uids = {src-&gt;parent_uid};
  if (mask) ds_uids.push_back(mask-&gt;parent_uid);

  GDALAsyncableJob&lt;CPLErr&gt; job(ds_uids);
  job.persist(src-&gt;handle());
  if (mask) job.persist(mask-&gt;handle());
  job.main = [gdal_src, gdal_mask, search_dist, smooth_iterations](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    CPLErr err = GDALFillNodata(gdal_src, gdal_mask, search_dist, 0, smooth_iterations, NULL, NULL, NULL);
    if (err) { throw CPLGetLastErrorMsg(); }
    return err;
  };
  job.rval = [](CPLErr r, GetFromPersistentFunc) { return Nan::Undefined().As&lt;Value&gt;(); };
  job.run(info, async, 1);
}

/**
 * @typedef ContourOptions { src: gdal.RasterBand, dst: gdal.Layer, offset?: number, interval?: number, fixedLevels?: number[], nodata?: number, idField?: number, elevField?: number, progress_cb?: ProgressCb }
 */

/**
 * Create vector contours from raster DEM.
 *
 * This algorithm will generate contour vectors for the input raster band on the
 * requested set of contour levels. The vector contours are written to the
 * passed in vector layer. Also, a NODATA value may be specified to identify
 * pixels that should not be considered in contour line generation.
 *
 * @throws Error
 * @method contourGenerate
 * @static
 * @for gdal
 * @param {ContourOptions} options
 * @param {gdal.RasterBand} options.src
 * @param {gdal.Layer} options.dst
 * @param {number} [options.offset=0] The &quot;offset&quot; relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, ... the offset would be 5.
 * @param {number} [options.interval=100] The elevation interval between contours generated.
 * @param {number[]} [options.fixedLevels] A list of fixed contour levels at which contours should be generated. Overrides interval/base options if set.
 * @param {number} [options.nodata] The value to use as a &quot;nodata&quot; value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.
 * @param {number} [options.idField] A field index to indicate where a unique id should be written for each feature (contour) written.
 * @param {number} [options.elevField] A field index to indicate where the elevation value of the contour should be written.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
*/

/**
 * Create vector contours from raster DEM.
 * {{{async}}}
 *
 * This algorithm will generate contour vectors for the input raster band on the
 * requested set of contour levels. The vector contours are written to the
 * passed in vector layer. Also, a NODATA value may be specified to identify
 * pixels that should not be considered in contour line generation.
 *
 * @throws Error
 * @method contourGenerateAsync
 * @static
 * @for gdal
 * @param {ContourOptions} options
 * @param {gdal.RasterBand} options.src
 * @param {gdal.Layer} options.dst
 * @param {number} [options.offset=0] The &quot;offset&quot; relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, ... the offset would be 5.
 * @param {number} [options.interval=100] The elevation interval between contours generated.
 * @param {number[]} [options.fixedLevels] A list of fixed contour levels at which contours should be generated. Overrides interval/base options if set.
 * @param {number} [options.nodata] The value to use as a &quot;nodata&quot; value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.
 * @param {number} [options.idField] A field index to indicate where a unique id should be written for each feature (contour) written.
 * @param {number} [options.elevField] A field index to indicate where the elevation value of the contour should be written.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Algorithms::contourGenerate) {
  Nan::HandleScope scope;

  Local&lt;Object&gt; obj;
  Local&lt;Value&gt; prop;
  RasterBand *src;
  Layer *dst;
  double interval = 100, base = 0;
  double *fixed_levels = NULL;
  DoubleList fixed_level_array;
  int n_fixed_levels = 0;
  int use_nodata = 0;
  double nodata = 0;
  int id_field = -1, elev_field = -1;
  Nan::Callback *progress_cb = nullptr;

  NODE_ARG_OBJECT(0, &quot;options&quot;, obj);

  NODE_WRAPPED_FROM_OBJ(obj, &quot;src&quot;, RasterBand, src);
  NODE_WRAPPED_FROM_OBJ(obj, &quot;dst&quot;, Layer, dst);
  NODE_INT_FROM_OBJ_OPT(obj, &quot;idField&quot;, id_field);
  NODE_INT_FROM_OBJ_OPT(obj, &quot;elevField&quot;, elev_field);
  NODE_DOUBLE_FROM_OBJ_OPT(obj, &quot;interval&quot;, interval);
  NODE_DOUBLE_FROM_OBJ_OPT(obj, &quot;offset&quot;, base);
  NODE_CB_FROM_OBJ_OPT(obj, &quot;progress_cb&quot;, progress_cb);
  if (Nan::HasOwnProperty(obj, Nan::New(&quot;fixedLevels&quot;).ToLocalChecked()).FromMaybe(false)) {
    if (fixed_level_array.parse(Nan::Get(obj, Nan::New(&quot;fixedLevels&quot;).ToLocalChecked()).ToLocalChecked())) {
      return; // error parsing double list
    } else {
      fixed_levels = fixed_level_array.get();
      n_fixed_levels = fixed_level_array.length();
    }
  }
  if (Nan::HasOwnProperty(obj, Nan::New(&quot;nodata&quot;).ToLocalChecked()).FromMaybe(false)) {
    prop = Nan::Get(obj, Nan::New(&quot;nodata&quot;).ToLocalChecked()).ToLocalChecked();
    if (prop-&gt;IsNumber()) {
      use_nodata = 1;
      nodata = Nan::To&lt;double&gt;(prop).ToChecked();
    } else if (!prop-&gt;IsNull() &amp;&amp; !prop-&gt;IsUndefined()) {
      Nan::ThrowTypeError(&quot;nodata property must be a number&quot;);
    }
  }

  GDALRasterBand *gdal_src = src-&gt;get();
  OGRLayer *gdal_dst = dst-&gt;get();

  long src_uid = src-&gt;parent_uid;
  long dst_uid = dst-&gt;parent_uid;

  GDALAsyncableJob&lt;CPLErr&gt; job({src_uid, dst_uid});
  job.progress = progress_cb;
  job.main = [gdal_src,
              interval,
              base,
              n_fixed_levels,
              fixed_levels,
              use_nodata,
              nodata,
              gdal_dst,
              id_field,
              elev_field,
              progress_cb](const GDALExecutionProgress &amp;progress) {
    CPLErrorReset();
    CPLErr err = GDALContourGenerate(
      gdal_src,
      interval,
      base,
      n_fixed_levels,
      fixed_levels,
      use_nodata,
      nodata,
      gdal_dst,
      id_field,
      elev_field,
      progress_cb ? ProgressTrampoline : nullptr,
      progress_cb ? (void *)&amp;progress : nullptr);
    if (err) { throw CPLGetLastErrorMsg(); }
    return err;
  };
  job.rval = [](CPLErr r, GetFromPersistentFunc) { return Nan::Undefined().As&lt;Value&gt;(); };
  job.run(info, async, 1);
}

/**
 * @typedef SieveOptions { src: gdal.RasterBand, dst: gdal.RasterBand, mask?: gdal.RasterBand, threshold: number, connectedness?: number, progress_cb?: ProgressCb }
 */

/**
 * Removes small raster polygons.
 *
 * @throws Error
 * @method sieveFilter
 * @static
 * @for gdal
 * @param {SieveOptions} options
 * @param {gdal.RasterBand} options.src
 * @param {gdal.RasterBand} options.dst Output raster band. It may be the same as src band to update the source in place.
 * @param {gdal.RasterBand} [options.mask] All pixels in the mask band with a value other than zero will be considered suitable for inclusion in polygons.
 * @param {number} options.threshold Raster polygons with sizes smaller than this will be merged into their largest neighbour.
 * @param {number} [options.connectedness=4] Either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 */

/**
 * Removes small raster polygons.
 * {{{async}}}
 *
 * @throws Error
 * @method sieveFilterAsync
 * @static
 * @for gdal
 * @param {SieveOptions} options
 * @param {gdal.RasterBand} options.src
 * @param {gdal.RasterBand} options.dst Output raster band. It may be the same as src band to update the source in place.
 * @param {gdal.RasterBand} [options.mask] All pixels in the mask band with a value other than zero will be considered suitable for inclusion in polygons.
 * @param {number} options.threshold Raster polygons with sizes smaller than this will be merged into their largest neighbour.
 * @param {number} [options.connectedness=4] Either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Algorithms::sieveFilter) {
  Nan::HandleScope scope;

  Local&lt;Object&gt; obj;
  RasterBand *src;
  RasterBand *dst;
  RasterBand *mask = NULL;
  int threshold;
  int connectedness = 4;
  Nan::Callback *progress_cb = nullptr;

  NODE_ARG_OBJECT(0, &quot;options&quot;, obj);

  NODE_WRAPPED_FROM_OBJ(obj, &quot;src&quot;, RasterBand, src);
  NODE_WRAPPED_FROM_OBJ(obj, &quot;dst&quot;, RasterBand, dst);
  NODE_WRAPPED_FROM_OBJ_OPT(obj, &quot;mask&quot;, RasterBand, mask);
  NODE_INT_FROM_OBJ(obj, &quot;threshold&quot;, threshold);
  NODE_INT_FROM_OBJ_OPT(obj, &quot;connectedness&quot;, connectedness);
  NODE_CB_FROM_OBJ_OPT(obj, &quot;progress_cb&quot;, progress_cb);

  if (connectedness != 4 &amp;&amp; connectedness != 8) {
    Nan::ThrowError(&quot;connectedness option must be 4 or 8&quot;);
    return;
  }

  GDALRasterBand *gdal_src = src-&gt;get();
  GDALRasterBand *gdal_dst = dst-&gt;get();
  GDALRasterBand *gdal_mask = mask ? mask-&gt;get() : nullptr;

  std::vector&lt;long&gt; ds_uids = {src-&gt;parent_uid, dst-&gt;parent_uid};
  if (mask) ds_uids.push_back(mask-&gt;parent_uid);

  GDALAsyncableJob&lt;CPLErr&gt; job(ds_uids);
  job.progress = progress_cb;
  job.main =
    [gdal_src, gdal_dst, gdal_mask, threshold, connectedness, progress_cb](const GDALExecutionProgress &amp;progress) {
      CPLErrorReset();
      CPLErr err = GDALSieveFilter(
        gdal_src,
        gdal_mask,
        gdal_dst,
        threshold,
        connectedness,
        NULL,
        progress_cb ? ProgressTrampoline : nullptr,
        progress_cb ? (void *)&amp;progress : nullptr);
      if (err) { throw CPLGetLastErrorMsg(); }
      return err;
    };
  job.rval = [](CPLErr r, GetFromPersistentFunc) { return Nan::Undefined().As&lt;Value&gt;(); };
  job.run(info, async, 1);
}

/**
 * Compute checksum for image region.
 *
 * @throws Error
 * @method checksumImage
 * @static
 * @for gdal
 * @param {gdal.RasterBand} src
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [w=src.width]
 * @param {number} [h=src.height]
 * @return {number}
 */

/**
 * Compute checksum for image region.
 *
 * @throws Error
 * @method checksumImageAsync
 * @static
 * @for gdal
 * @param {gdal.RasterBand} src
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [w=src.width]
 * @param {number} [h=src.height]
 * @param {callback&lt;number&gt;} [callback=undefined] {{{cb}}}
 * @return {number}
 * @return {Promise&lt;number&gt;}
 */

GDAL_ASYNCABLE_DEFINE(Algorithms::checksumImage) {
  Nan::HandleScope scope;

  RasterBand *src;
  int x = 0, y = 0, w, h, bandw, bandh;

  NODE_ARG_WRAPPED(0, &quot;src&quot;, RasterBand, src);

  w = bandw = src-&gt;get()-&gt;GetXSize();
  h = bandh = src-&gt;get()-&gt;GetYSize();

  NODE_ARG_INT_OPT(1, &quot;x&quot;, x);
  NODE_ARG_INT_OPT(2, &quot;y&quot;, y);
  NODE_ARG_INT_OPT(3, &quot;xSize&quot;, w);
  NODE_ARG_INT_OPT(4, &quot;ySize&quot;, h);

  if (x &lt; 0 || y &lt; 0 || x &gt;= bandw || y &gt;= bandh) {
    Nan::ThrowRangeError(&quot;offset invalid for given band&quot;);
    return;
  }
  if (w &lt; 0 || h &lt; 0 || w &gt; bandw || h &gt; bandh) {
    Nan::ThrowRangeError(&quot;x and y size must be smaller than band dimensions and greater than 0&quot;);
    return;
  }
  if (x + w - 1 &gt;= bandw || y + h - 1 &gt;= bandh) {
    Nan::ThrowRangeError(&quot;given range is outside bounds of given band&quot;);
    return;
  }

  GDALRasterBand *gdal_src = src-&gt;get();
  long src_uid = src-&gt;parent_uid;

  GDALAsyncableJob&lt;int&gt; job(src_uid);
  job.main = [gdal_src, x, y, w, h](const GDALExecutionProgress &amp;) {
    int r = GDALChecksumImage(gdal_src, x, y, w, h);
    return r;
  };
  job.rval = [](int r, GetFromPersistentFunc) { return Nan::New&lt;Integer&gt;(r); };
  job.run(info, async, 5);
}

/**
 * @typedef PolygonizeOptions { src: gdal.RasterBand, dst: gdal.Layer, mask?: gdal.RasterBand, pixValField: number, connectedness?: number, useFloats?: boolean, progress_cb?: ProgressCb }
 */

/**
 * Creates vector polygons for all connected regions of pixels in the raster
 * sharing a common pixel value. Each polygon is created with an attribute
 * indicating the pixel value of that polygon. A raster mask may also be
 * provided to determine which pixels are eligible for processing.
 *
 * @throws Error
 * @method polygonize
 * @static
 * @for gdal
 * @param {PolygonizeOptions} options
 * @param {gdal.RasterBand} options.src
 * @param {gdal.Layer} options.dst
 * @param {gdal.RasterBand} [options.mask]
 * @param {number} options.pixValField The attribute field index indicating the feature attribute into which the pixel value of the polygon should be written.
 * @param {number} [options.connectedness=4] Either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are.
 * @param {boolean} [options.useFloats=false] Use floating point buffers instead of int buffers.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 */

/**
 * Creates vector polygons for all connected regions of pixels in the raster
 * sharing a common pixel value. Each polygon is created with an attribute
 * indicating the pixel value of that polygon. A raster mask may also be
 * provided to determine which pixels are eligible for processing.
 *
 * @throws Error
 * @method polygonizeAsync
 * @static
 * @for gdal
 * @param {PolygonizeOptions} options
 * @param {gdal.RasterBand} options.src
 * @param {gdal.Layer} options.dst
 * @param {gdal.RasterBand} [options.mask]
 * @param {number} options.pixValField The attribute field index indicating the feature attribute into which the pixel value of the polygon should be written.
 * @param {number} [options.connectedness=4] Either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are.
 * @param {boolean} [options.useFloats=false] Use floating point buffers instead of int buffers.
 * @param {ProgressCb} [options.progress_cb] {{{progress_cb}}}
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */
GDAL_ASYNCABLE_DEFINE(Algorithms::polygonize) {
  Nan::HandleScope scope;

  Local&lt;Object&gt; obj;
  RasterBand *src;
  RasterBand *mask = NULL;
  Layer *dst;
  int connectedness = 4;
  int pix_val_field = 0;
  char **papszOptions = NULL;
  Nan::Callback *progress_cb = nullptr;

  NODE_ARG_OBJECT(0, &quot;options&quot;, obj);

  NODE_WRAPPED_FROM_OBJ(obj, &quot;src&quot;, RasterBand, src);
  NODE_WRAPPED_FROM_OBJ(obj, &quot;dst&quot;, Layer, dst);
  NODE_WRAPPED_FROM_OBJ_OPT(obj, &quot;mask&quot;, RasterBand, mask);
  NODE_INT_FROM_OBJ_OPT(obj, &quot;connectedness&quot;, connectedness)
  NODE_INT_FROM_OBJ(obj, &quot;pixValField&quot;, pix_val_field);
  NODE_CB_FROM_OBJ_OPT(obj, &quot;progress_cb&quot;, progress_cb);

  if (connectedness == 8) {
    papszOptions = CSLSetNameValue(papszOptions, &quot;8CONNECTED&quot;, &quot;8&quot;);
  } else if (connectedness != 4) {
    Nan::ThrowError(&quot;connectedness must be 4 or 8&quot;);
    return;
  }

  GDALRasterBand *gdal_src = src-&gt;get();
  OGRLayer *gdal_dst = dst-&gt;get();
  GDALRasterBand *gdal_mask = mask ? mask-&gt;get() : nullptr;

  std::vector&lt;long&gt; ds_uids = {src-&gt;parent_uid, dst-&gt;parent_uid};
  if (mask) ds_uids.push_back(mask-&gt;parent_uid);

  GDALAsyncableJob&lt;CPLErr&gt; job(ds_uids);
  job.progress = progress_cb;

  if (
    Nan::HasOwnProperty(obj, Nan::New(&quot;useFloats&quot;).ToLocalChecked()).FromMaybe(false) &amp;&amp;
    Nan::To&lt;bool&gt;(Nan::Get(obj, Nan::New(&quot;useFloats&quot;).ToLocalChecked()).ToLocalChecked()).ToChecked()) {
    job.main =
      [gdal_src, gdal_mask, gdal_dst, pix_val_field, papszOptions, progress_cb](const GDALExecutionProgress &amp;progress) {
        CPLErrorReset();
        CPLErr err = GDALFPolygonize(
          gdal_src,
          gdal_mask,
          reinterpret_cast&lt;OGRLayerH&gt;(gdal_dst),
          pix_val_field,
          papszOptions,
          progress_cb ? ProgressTrampoline : nullptr,
          progress_cb ? (void *)&amp;progress : nullptr);
        if (papszOptions) CSLDestroy(papszOptions);
        if (err) throw CPLGetLastErrorMsg();
        return err;
      };
  } else {
    job.main =
      [gdal_src, gdal_mask, gdal_dst, pix_val_field, papszOptions, progress_cb](const GDALExecutionProgress &amp;progress) {
        CPLErrorReset();
        CPLErr err = GDALPolygonize(
          gdal_src,
          gdal_mask,
          reinterpret_cast&lt;OGRLayerH&gt;(gdal_dst),
          pix_val_field,
          papszOptions,
          progress_cb ? ProgressTrampoline : nullptr,
          progress_cb ? (void *)&amp;progress : nullptr);
        if (papszOptions) CSLDestroy(papszOptions);
        if (err) throw CPLGetLastErrorMsg();
        return err;
      };
  }
  job.rval = [](CPLErr r, GetFromPersistentFunc) { return Nan::Undefined().As&lt;Value&gt;(); };
  job.run(info, async, 1);
}

// This is used for stress-testing the locking mechanism
// it doesn&#x27;t do anything but sollicit locks
GDAL_ASYNCABLE_DEFINE(Algorithms::_acquireLocks) {
  Nan::HandleScope scope;
  Dataset *ds1, *ds2, *ds3;

  NODE_ARG_WRAPPED(0, &quot;ds1&quot;, Dataset, ds1);
  NODE_ARG_WRAPPED(1, &quot;ds2&quot;, Dataset, ds2);
  NODE_ARG_WRAPPED(2, &quot;ds3&quot;, Dataset, ds3);

  GDALAsyncableJob&lt;int&gt; job({ds1-&gt;uid, ds2-&gt;uid, ds3-&gt;uid});
  job.main = [](const GDALExecutionProgress &amp;) {
    int i, sum = 0;
    // make sure the optimizer won&#x27;t surprise us
    for (i = 0; i &lt; 1e4; i++) sum += i;
    return sum;
  };
  job.rval = [](int, GetFromPersistentFunc) { return Nan::Undefined().As&lt;Value&gt;(); };
  job.run(info, async, 3);
}

} // namespace node_gdal

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
