<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/gdal.js - node-gdal-async</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-async" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-async">
            node-gdal-async
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>3.3.6</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DIM)", "classes/Constants (DIR)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.ArrayAttributes", "classes/gdal.ArrayDimensions", "classes/gdal.Attribute", "classes/gdal.CircularString", "classes/gdal.CompoundCurve", "classes/gdal.CompoundCurveCurves", "classes/gdal.config", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Dimension", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Group", "classes/gdal.GroupArrays", "classes/gdal.GroupAttributes", "classes/gdal.GroupDimensions", "classes/gdal.GroupGroups", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MDArray", "classes/gdal.MultiCurve", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.SimpleCurve", "classes/gdal.SpatialReference", "classes/vsimem
Operations on in-memory /vsimem/ files"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DIM).html">Constants (DIM)</a></li>
                <li><a href="../classes/Constants (DIR).html">Constants (DIR)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.ArrayAttributes.html">gdal.ArrayAttributes</a></li>
                <li><a href="../classes/gdal.ArrayDimensions.html">gdal.ArrayDimensions</a></li>
                <li><a href="../classes/gdal.Attribute.html">gdal.Attribute</a></li>
                <li><a href="../classes/gdal.CircularString.html">gdal.CircularString</a></li>
                <li><a href="../classes/gdal.CompoundCurve.html">gdal.CompoundCurve</a></li>
                <li><a href="../classes/gdal.CompoundCurveCurves.html">gdal.CompoundCurveCurves</a></li>
                <li><a href="../classes/gdal.config.html">gdal.config</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Dimension.html">gdal.Dimension</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Group.html">gdal.Group</a></li>
                <li><a href="../classes/gdal.GroupArrays.html">gdal.GroupArrays</a></li>
                <li><a href="../classes/gdal.GroupAttributes.html">gdal.GroupAttributes</a></li>
                <li><a href="../classes/gdal.GroupDimensions.html">gdal.GroupDimensions</a></li>
                <li><a href="../classes/gdal.GroupGroups.html">gdal.GroupGroups</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MDArray.html">gdal.MDArray</a></li>
                <li><a href="../classes/gdal.MultiCurve.html">gdal.MultiCurve</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.SimpleCurve.html">gdal.SimpleCurve</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
                <li><a href="../classes/vsimem
Operations on in-memory /vsimem/ files.html">vsimem
Operations on in-memory /vsimem/ files</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>lib/gdal.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
const path = require(&#x27;path&#x27;)
const fs = require(&#x27;fs&#x27;)
const binary = require(&#x27;@mapbox/node-pre-gyp&#x27;)

const binding_path = binary.find(path.resolve(path.join(__dirname, &#x27;../package.json&#x27;)))
const gdal = require(binding_path)

const data_path = path.resolve(__dirname, &#x27;../deps/libgdal/gdal/data&#x27;)
const proj_path = path.resolve(__dirname, &#x27;../deps/libproj/proj/data&#x27;)

if (process.env.GDAL_DATA === undefined &amp;&amp; !fs.existsSync(data_path)) {
  throw new Error(
    &#x60;The bundled data path for node-gdal is missing &#x27;${data_path}&#x27; and GDAL_DATA environment is not set&#x60;
  )
}

const proj_lib_env_undefined = process.env.PROJ_LIB === undefined
if (proj_lib_env_undefined &amp;&amp; !fs.existsSync(proj_path)) {
  throw new Error(
    &#x60;The bundled proj data path for node-gdal is missing &#x27;${proj_path}&#x27; and PROJ_LIB environment is not set&#x60;
  )
}

module.exports = gdal

if (proj_lib_env_undefined &amp;&amp; gdal.bundled) {
  gdal.setPROJSearchPath(proj_path)
}

gdal.Point.Multi = gdal.MultiPoint
gdal.LineString.Multi = gdal.MultiLineString
gdal.LinearRing.Multi = gdal.MultiLineString
gdal.Polygon.Multi = gdal.MultiPolygon

gdal.quiet()

gdal.config = {}

/**
 * @class gdal.config
 */

/**
 * Gets a GDAL configuration setting.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * data_path = gdal.config.get(&#x27;GDAL_DATA&#x27;);&#x60;&#x60;&#x60;
 *
 * @static
 * @method get
 * @param {string} key
 * @return {string}
 */
gdal.config.get = gdal.getConfigOption

/**
 * Sets a GDAL configuration setting.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * gdal.config.set(&#x27;GDAL_DATA&#x27;, data_path);&#x60;&#x60;&#x60;
 *
 * @static
 * @method set
 * @param {string} key
 * @param {string} value
 * @return {void}
 */
gdal.config.set = gdal.setConfigOption

delete gdal.getConfigOption
delete gdal.setConfigOption

if (process.env.CURL_CA_BUNDLE === undefined) {
  gdal.config.set(&#x27;CURL_CA_BUNDLE&#x27;, path.resolve(__dirname, &#x27;../deps/libcurl/cacert.pem&#x27;))
}

/**
 * Callback using the standard Node.js error convention
 * @element callback
 * @typedef callback&lt;T&gt; (Error, T) =&gt; void
 */

if (process.env.GDAL_DATA === undefined &amp;&amp; gdal.bundled) {
  gdal.config.set(&#x27;GDAL_DATA&#x27;, data_path)
}

gdal.Envelope = require(&#x27;./envelope.js&#x27;)(gdal)
gdal.Envelope3D = require(&#x27;./envelope_3d.js&#x27;)(gdal)

const getEnvelope = gdal.Geometry.prototype.getEnvelope
gdal.Geometry.prototype.getEnvelope = function () {
  const obj = getEnvelope.apply(this, arguments)
  return new gdal.Envelope(obj)
}

const getEnvelope3D = gdal.Geometry.prototype.getEnvelope3D
gdal.Geometry.prototype.getEnvelope3D = function () {
  const obj = getEnvelope3D.apply(this, arguments)
  return new gdal.Envelope3D(obj)
}

const getEnvelopeAsync = gdal.Geometry.prototype.getEnvelopeAsync
gdal.Geometry.prototype.getEnvelopeAsync = function () {
  // arguments[arguments.length - 1] is the callback
  const old_cb = arguments[arguments.length - 1]
  const new_cb = (e, r) =&gt; {
    const obj = e ? undefined : new gdal.Envelope(r)
    old_cb(e, obj)
  }
  arguments[arguments.length - 1] = new_cb
  getEnvelopeAsync.apply(this, arguments)
}

const getEnvelope3DAsync = gdal.Geometry.prototype.getEnvelope3DAsync
gdal.Geometry.prototype.getEnvelope3DAsync = function () {
  const old_cb = arguments[arguments.length - 1]
  const new_cb = (e, r) =&gt; {
    const obj = e ? undefined : new gdal.Envelope3D(r)
    old_cb(e, obj)
  }
  arguments[arguments.length - 1] = new_cb
  getEnvelope3DAsync.apply(this, arguments)
}

const getExtent = gdal.Layer.prototype.getExtent
gdal.Layer.prototype.getExtent = function () {
  const obj = getExtent.apply(this, arguments)
  return new gdal.Envelope(obj)
}

/**
 * Returns a {{#crossLink &quot;Envelope&quot;}}gdal.Envelope{{/crossLink}} object for the raster bands
 *
 * @example
 * &#x60;&#x60;&#x60;
 * const extent = dataset.getEnvelope()
 * &#x60;&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetBands
 * @method getEnvelope
 * @return {Envelope}
 */
gdal.DatasetBands.prototype.getEnvelope = function () {
  const ulx = this.ds.geoTransform[0]
  const uly = this.ds.geoTransform[3]
  const lrx = this.ds.geoTransform[0] + this.ds.geoTransform[1] * this.ds.rasterSize.x
  const lry = this.ds.geoTransform[3] + this.ds.geoTransform[5] * this.ds.rasterSize.y
  return new gdal.Envelope({
    minX: Math.min(ulx, lrx),
    minY: Math.min(uly, lry),
    maxX: Math.max(ulx, lrx),
    maxY: Math.max(uly, lry)
  })
}

/**
 * @interface xyz { x: number, y: number, z?: number }
 */

// --- add additional functionality to collections ---

/**
 * A simple key/value structure
 * @interface fieldValue { key: string, value: any }
 */

/**
 * forEach() callback type
 * @element forEachCb
 * @typedef forEachCb&lt;T&gt; (obj: T, idx: number) =&gt; boolean|void
 */
function defaultForEach(callback) {
  const n = this.count()
  for (let i = 0; i &lt; n; i++) {
    if (callback(this.get(i), i) === false) return
  }
}

/**
 * map() callback type
 * @element mapCb
 * @typedef mapCb&lt;T,U&gt; (obj: T, index: number) =&gt; U
 */
function defaultMap(callback) {
  const result = []
  this.forEach((value, i) =&gt; {
    result.push(callback(value, i))
  })
  return result
}

function defaultToArray() {
  const array = []
  this.forEach((geom) =&gt; {
    array.push(geom)
  })
  return array
}

function defaultIterator() {
  let i = 0

  return {
    next: () =&gt; {
      const done = !(i &lt; this.count())
      return {
        done,
        value: done ? null : this.get(i++)
      }
    }
  }
}

/**
 * Iterates through all bands using a callback function.
 * Note: GDAL band indexes start at 1, not 0.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * dataset.bands.forEach(function(band, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetBands
 * @method forEach
 * @param {forEachCb&lt;gdal.RasterBand&gt;} callback The callback to be called with each {{#crossLink &quot;RasterBand&quot;}}RasterBand{{/crossLink}}
 */
gdal.DatasetBands.prototype.forEach = function (callback) {
  const n = this.count()
  for (let i = 1; i &lt;= n; i++) {
    if (callback(this.get(i), i) === false) return
  }
}

/**
 * Iterates through all bands using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = dataset.bands.map(function(band, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetBands
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.RasterBand,U&gt;} callback The callback to be called with each {{#crossLink &quot;RasterBand&quot;}}RasterBand{{/crossLink}}
 * @return {U[]}
 */
gdal.DatasetBands.prototype.map = defaultMap

/**
 * Iterates through all bands using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const band of dataset.bands) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetBands
 * @type {gdal.RasterBand}
 * @method Symbol.iterator
 */
gdal.DatasetBands.prototype[Symbol.iterator] = function () {
  let i = 1

  return {
    next: () =&gt; {
      const done = !(i &lt;= this.count())
      return {
        done,
        value: done ? null : this.get(i++)
      }
    }
  }
}

/**
 * Iterates through all features using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * layer.features.forEach(function(feature, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.LayerFeatures
 * @method forEach
 * @param {forEachCb&lt;gdal.Feature&gt;} callback The callback to be called with each {{#crossLink &quot;Feature&quot;}}Feature{{/crossLink}}
 */
gdal.LayerFeatures.prototype.forEach = function (callback) {
  let i = 0
  let feature = this.first()
  while (feature) {
    if (callback(feature, i++) === false) return
    feature = this.next()
  }
}

/**
 * Iterates through all features using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = layer.features.map(function(band, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.LayerFeatures
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Feature,U&gt;} callback The callback to be called with each {{#crossLink &quot;Feature&quot;}}Feature{{/crossLink}}
 * @return {U[]}
 */
gdal.LayerFeatures.prototype.map = defaultMap

/**
 * Iterates through all features using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const feature of layer.features) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.LayerFeatures
 * @type {gdal.Feature}
 * @method Symbol.iterator
 */
gdal.LayerFeatures.prototype[Symbol.iterator] = function defaultIterator() {
  let feature

  return {
    next: () =&gt; {
      feature = feature ? this.next() : this.first()
      return {
        done: !feature,
        value: feature
      }
    }
  }
}

/**
 * Iterates through all fields using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * layer.features.get(0).fields.forEach(function(value, key) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.FeatureFields
 * @method forEach
 * @param {forEachCb&lt;fieldValue&gt;} callback The callback to be called with each feature &#x60;value&#x60; and &#x60;key&#x60;.
 */
gdal.FeatureFields.prototype.forEach = function (callback) {
  const obj = this.toObject()
  Object.entries(obj).every(([ k, v ]) =&gt;
    callback(v, k) !== false
  )
}

/**
 * Iterates through all fields using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = layer.features.get(0).fields.map(function(value, key) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.FeatureFields
 * @method map&lt;U&gt;
 * @param {mapCb&lt;fieldValue,U&gt;} callback The callback to be called with each feature &#x60;value&#x60; and &#x60;key&#x60;.
 * @return {U[]}
 */
gdal.FeatureFields.prototype.map = defaultMap

/**
 * Outputs the fields as a serialized JSON string.
 *
 * @for gdal.FeatureFields
 * @method toJSON
 * @return {string} Serialized JSON
 */
gdal.FeatureFields.prototype.toJSON = function () {
  return JSON.stringify(this.toObject())
}

/**
 * Converts the geometry to a GeoJSON object representation.
 *
 * @for gdal.Geometry
 * @method toObject
 * @return {object} GeoJSON
 */
gdal.Geometry.prototype.toObject = function () {
  return JSON.parse(this.toJSON())
}

/**
 * Iterates through all field definitions using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * layer.fields.forEach(function(field, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.LayerFields
 * @method forEach
 * @param {forEachCb&lt;gdal.FieldDefn&gt;} callback The callback to be called with each {{#crossLink &quot;FieldDefn&quot;}}FieldDefn{{/crossLink}}
 */
gdal.LayerFields.prototype.forEach = defaultForEach

/**
 * Iterates through all field definitions using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = layer.fields.map(function(field, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.LayerFields
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.FieldDefn,U&gt;} callback The callback to be called with each {{#crossLink &quot;FieldDefn&quot;}}FieldDefn{{/crossLink}}
 * @return {U[]}
 */
gdal.LayerFields.prototype.map = defaultMap

/**
 * Iterates through all field definitions using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const curve of layer.fields) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.LayerFields
 * @type {gdal.FieldDefn}
 * @method Symbol.iterator
 */
gdal.LayerFields.prototype[Symbol.iterator] = defaultIterator

/**
 * Iterates through all layers using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * dataset.layers.forEach(function(layer, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetLayers
 * @method forEach
 * @param {forEachCb&lt;gdal.Layer&gt;} callback The callback to be called with each {{#crossLink &quot;Layer&quot;}}Layer{{/crossLink}}
 */
gdal.DatasetLayers.prototype.forEach = defaultForEach

/**
 * Iterates through all layers using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = dataset.layers.map(function(field, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetLayers
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Layer,U&gt;} callback The callback to be called with each {{#crossLink &quot;Layer&quot;}}Layer{{/crossLink}}
 * @return {U[]}
 */
gdal.DatasetLayers.prototype.map = defaultMap

/**
 * Iterates through all layers using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const curve of dataset.layers) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.DatasetLayers
 * @type {gdal.Layer}
 * @method Symbol.iterator
 */
gdal.DatasetLayers.prototype[Symbol.iterator] = defaultIterator

/**
 * Iterates through all field definitions using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * featureDefn.forEach(function(field, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.FeatureDefnFields
 * @method forEach
 * @param {forEachCb&lt;gdal.FieldDefn&gt;} callback The callback to be called with each {{#crossLink &quot;FieldDefn&quot;}}FieldDefn{{/crossLink}}
 */
gdal.FeatureDefnFields.prototype.forEach = defaultForEach

/**
 * Iterates through all field definitions using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = featureDefn.map(function(field, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.FeatureDefnFields
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.FieldDefn,U&gt;} callback The callback to be called with each {{#crossLink &quot;FieldDefn&quot;}}FieldDefn{{/crossLink}}
 * @return {U[]}
 */
gdal.FeatureDefnFields.prototype.map = defaultMap

/**
 * Iterates through all field definitions using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const defn of featureDefn) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.FeatureDefnFields
 * @type {gdal.FieldDefn}
 * @method Symbol.iterator
 */
gdal.FeatureDefnFields.prototype[Symbol.iterator] = defaultIterator

/**
 * Iterates through all rings using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * polygon.rings.forEach(function(ring, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.PolygonRings
 * @method forEach
 * @param {forEachCb&lt;gdal.LineString&gt;} callback The callback to be called with each {{#crossLink &quot;LineString&quot;}}LineString{{/crossLink}}
 */
gdal.PolygonRings.prototype.forEach = defaultForEach

/**
 * Iterates through all rings using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = polygon.rings.map(function(ring, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.PolygonRings
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.LineString,U&gt;} callback The callback to be called with each {{#crossLink &quot;LineString&quot;}}LineString{{/crossLink}}
 * @return {U[]}
 */
gdal.PolygonRings.prototype.map = defaultMap

/**
 * Iterates through all rings using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const ring of polygon.rings) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.PolygonRings
 * @type {gdal.LineString}
 * @method Symbol.iterator
 */
gdal.PolygonRings.prototype[Symbol.iterator] = defaultIterator

/**
 * Iterates through all points using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * lineString.points.forEach(function(point, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.LineStringPoints
 * @method forEach
 * @param {forEachCb&lt;gdal.Point&gt;} callback The callback to be called with each {{#crossLink &quot;Point&quot;}}Point{{/crossLink}}
 */
gdal.LineStringPoints.prototype.forEach = defaultForEach

/**
 * Iterates through all points using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = lineString.points.map(function(point, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.LineStringPoints
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Point,U&gt;} callback The callback to be called with each {{#crossLink &quot;Point&quot;}}Point{{/crossLink}}
 * @return {U[]}
 */
gdal.LineStringPoints.prototype.map = defaultMap

/**
 * Iterates through all points using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const point of lineString.points) {
 * }&#x60;&#x60;&#x60;
 *
 * @for gdal.LineStringPoints
 * @type {gdal.Point}
 * @method Symbol.iterator
 */
gdal.LineStringPoints.prototype[Symbol.iterator] = defaultIterator

if (gdal.CompoundCurveCurves) {
  /**
   * Iterates through all curves using a callback function.
   *
   * @example
   * &#x60;&#x60;&#x60;
   * compoundCurve.curves.forEach(function(curve, i) { ... });&#x60;&#x60;&#x60;
   *
   * @for gdal.CompoundCurveCurves
   * @method forEach
   * @param {forEachCb&lt;gdal.SimpleCurve&gt;} callback The callback to be called with each {{#crossLink &quot;SimpleCurve&quot;}}SimpleCurve{{/crossLink}}
   */
  gdal.CompoundCurveCurves.prototype.forEach = defaultForEach

  /**
   * Iterates through all curves using a callback function and builds
   * an array of the returned values.
   *
   * @example
   * &#x60;&#x60;&#x60;
   * var result = compoundCurves.curves.map(function(curve, i) {
   *     return value;
   * });&#x60;&#x60;&#x60;
   *
   * @for gdal.CompoundCurveCurves
   * @method map&lt;U&gt;
   * @param {mapCb&lt;gdal.SimpleCurve,U&gt;} callback The callback to be called with each {{#crossLink &quot;SimpleCurve&quot;}}SimpleCurve{{/crossLink}}
   * @return {U[]}
   */
  gdal.CompoundCurveCurves.prototype.map = defaultMap

  /**
   * Iterates through all curves using an iterator
   *
   * @example
   * &#x60;&#x60;&#x60;
   * for (const curve of compoundCurves.curves) {
   * }
   *
   * @for gdal.CompoundCurveCurves
   * @type {gdal.SimpleCurve}
   * @method Symbol.iterator
   */
  gdal.CompoundCurveCurves.prototype[Symbol.iterator] = defaultIterator
}

/**
 * Iterates through all child geometries using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * geometryCollection.children.forEach(function(geometry, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.GeometryCollectionChildren
 * @method forEach
 * @param {forEachCb&lt;gdal.Geometry&gt;} callback The callback to be called with each {{#crossLink &quot;Geometry&quot;}}Geometry{{/crossLink}}
 */
gdal.GeometryCollectionChildren.prototype.forEach = defaultForEach

/**
 * Iterates through all child geometries using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = geometryCollection.children.map(function(geometry, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GeometryCollectionChildren
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Geometry,U&gt;} callback The callback to be called with each {{#crossLink &quot;Geometry&quot;}}Geometry{{/crossLink}}
 * @return {U[]}
 */
gdal.GeometryCollectionChildren.prototype.map = defaultMap

/**
 * Iterates through all overviews using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * band.overviews.forEach(function(overviewBand, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.RasterBandOverviews
 * @method forEach
 * @param {forEachCb&lt;gdal.RasterBand&gt;} callback
 */
gdal.RasterBandOverviews.prototype.forEach = defaultForEach

/**
 * Iterates through all raster overviews using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = band.overviews.map(function(overviewBand, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.RasterBandOverviews
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.RasterBand,U&gt;} callback The callback to be called with each {{#crossLink &quot;RasterBand&quot;}}RasterBand{{/crossLink}}
 * @return {U[]}
 */
gdal.RasterBandOverviews.prototype.map = defaultMap

/**
 * Iterates through all overview using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const overview of band.overviews) {
 * }
 *
 * @for gdal.RasterBandOverviews
 * @type {gdal.RasterBand}
 * @method Symbol.iterator
 */
gdal.RasterBandOverviews.prototype[Symbol.iterator] = defaultIterator

/**
 * Iterates through all registered drivers using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * gdal.drivers.forEach(function(driver, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.GDALDrivers
 * @method forEach
 * @param {forEachCb&lt;gdal.Driver&gt;} callback The callback to be called with each {{#crossLink &quot;Driver&quot;}}Driver{{/crossLink}}
 */
gdal.GDALDrivers.prototype.forEach = defaultForEach

/**
 * Iterates through all drivers using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = gdal.drivers.map(function(driver, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GDALDrivers
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Driver,U&gt;} callback The callback to be called with each {{#crossLink &quot;Driver&quot;}}Driver{{/crossLink}}
 * @return {U[]}
 */
gdal.GDALDrivers.prototype.map = defaultMap

/**
 * Iterates through all drivers using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const driver of gdal.drivers) {
 * }
 *
 * @for gdal.GDALDrivers
 * @type {gdal.Driver}
 * @method Symbol.iterator
 */
gdal.GDALDrivers.prototype[Symbol.iterator] = defaultIterator

/**
 * Outputs all geometries as a regular javascript array.
 *
 * @for gdal.GeometryCollectionChildren
 * @method toArray
 * @return {gdal.Geometry[]} List of {{#crossLink &quot;Geometry&quot;}}Geometry{{/crossLink}} instances.
 */
gdal.GeometryCollectionChildren.prototype.toArray = defaultToArray

/**
 * Outputs all points as a regular javascript array.
 *
 * @for gdal.LineStringPoints
 * @method toArray
 * @return {gdal.Point[]} List of {{#crossLink &quot;Point&quot;}}Point{{/crossLink}} instances.
 */
gdal.LineStringPoints.prototype.toArray = defaultToArray

/**
 * Outputs all rings as a regular javascript array.
 *
 * @for gdal.PolygonRings
 * @method toArray
 * @return {gdal.LineString[]} List of {{#crossLink &quot;LineString&quot;}}LineString{{/crossLink}} instances.
 */
gdal.PolygonRings.prototype.toArray = defaultToArray

if (gdal.MDArray) {
/**
 * Iterates through all arrays using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * group.arrays.forEach(function(array, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupArrays
 * @method forEach
 * @param {forEachCb&lt;gdal.MDArray&gt;} callback The callback to be called with each {{#crossLink &quot;MDArray&quot;}}MDArray{{/crossLink}}
 */
  gdal.GroupArrays.prototype.forEach = defaultForEach

  /**
 * Iterates through all arrays using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = group.arrays.map(function(array, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupArrays
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.MDArray,U&gt;} callback The callback to be called with each {{#crossLink &quot;MDArray&quot;}}MDArray{{/crossLink}}
 * @return {U[]}
 */
  gdal.GroupArrays.prototype.map = defaultMap

  /**
 * Iterates through all arrays using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const array of group.arrays) {
 * }
 *
 * @for gdal.GroupArrays
 * @type {gdal.MDArray}
 * @method Symbol.iterator
 */
  gdal.GroupArrays.prototype[Symbol.iterator] = defaultIterator

  /**
 * Iterates through all groups using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * group.groups.forEach(function(array, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupGroups
 * @method forEach
 * @param {forEachCb&lt;gdal.Group&gt;} callback The callback to be called with each {{#crossLink &quot;Group&quot;}}Group{{/crossLink}}
 */
  gdal.GroupGroups.prototype.forEach = defaultForEach

  /**
 * Iterates through all groups using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = group.groups.map(function(group, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupGroups
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Group,U&gt;} callback The callback to be called with each {{#crossLink &quot;Group&quot;}}Group{{/crossLink}}
 * @return {U[]}
 */
  gdal.GroupGroups.prototype.map = defaultMap

  /**
 * Iterates through all groups using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const group of group.groups) {
 * }
 *
 * @for gdal.GroupGroups
 * @type {gdal.Group}
 * @method Symbol.iterator
 */
  gdal.GroupGroups.prototype[Symbol.iterator] = defaultIterator

  /**
 * Iterates through all dimensions using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * group.dimensions.forEach(function(array, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupDimensions
 * @method forEach
 * @param {forEachCb&lt;gdal.Dimension&gt;} callback The callback to be called with each {{#crossLink &quot;Dimension&quot;}}Dimension{{/crossLink}}
 */
  gdal.GroupDimensions.prototype.forEach = defaultForEach

  /**
 * Iterates through all dimensions using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = group.dimensions.map(function(dimension, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupDimensions
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Dimension,U&gt;} callback The callback to be called with each {{#crossLink &quot;Dimension&quot;}}Dimension{{/crossLink}}
 * @return {U[]}
 */
  gdal.GroupDimensions.prototype.map = defaultMap

  /**
 * Iterates through all dimensions using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const dimension of group.dimensions) {
 * }
 *
 * @for gdal.GroupDimensions
 * @type {gdal.Dimension}
 * @method Symbol.iterator
 */
  gdal.GroupDimensions.prototype[Symbol.iterator] = defaultIterator

  /**
 * Iterates through all attributes using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * group.attributes.forEach(function(array, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupAttributes
 * @method forEach
 * @param {forEachCb&lt;gdal.Dimension&gt;} callback The callback to be called with each {{#crossLink &quot;Dimension&quot;}}Dimension{{/crossLink}}
 */
  gdal.GroupAttributes.prototype.forEach = defaultForEach

  /**
 * Iterates through all attributes using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = group.attributes.map(function(array, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupAttributes
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Attribute,U&gt;} callback The callback to be called with each {{#crossLink &quot;Attribute&quot;}}Attribute{{/crossLink}}
 * @return {U[]}
 */
  gdal.GroupAttributes.prototype.map = defaultMap

  /**
 * Iterates through all attributes using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const attribute of group.attributes) {
 * }
 *
 * @for gdal.GroupAttributes
 * @type {gdal.Attribute}
 * @method Symbol.iterator
 */
  gdal.GroupAttributes.prototype[Symbol.iterator] = defaultIterator

  /**
 * Iterates through all dimensions using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = array.dimensions.map(function(dimension, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.GroupDimensions
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Dimension,U&gt;} callback The callback to be called with each {{#crossLink &quot;Dimension&quot;}}Dimension{{/crossLink}}
 * @return {U[]}
 */
  gdal.ArrayDimensions.prototype.forEach = defaultForEach

  /**
 * Iterates through all dimensions using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = group.dimensions.map(function(array, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.ArrayDimensions
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Dimension,U&gt;} callback The callback to be called with each {{#crossLink &quot;Dimension&quot;}}Dimension{{/crossLink}}
 * @return {U[]}
 */
  gdal.ArrayDimensions.prototype.map = defaultMap

  /**
 * Iterates through all dimensions using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const dimension of group.dimensions) {
 * }
 *
 * @for gdal.ArrayDimensions
 * @type {gdal.Dimension}
 * @method Symbol.iterator
 */
  gdal.ArrayDimensions.prototype[Symbol.iterator] = defaultIterator

  /**
 * Iterates through all attributes using a callback function.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * group.attributes.forEach(function(array, i) { ... });&#x60;&#x60;&#x60;
 *
 * @for gdal.ArrayAttributes
 * @method forEach
 * @param {forEachCb&lt;gdal.Dimension&gt;} callback The callback to be called with each {{#crossLink &quot;Dimension&quot;}}Dimension{{/crossLink}}
 */
  gdal.ArrayAttributes.prototype.forEach = defaultForEach

  /**
 * Iterates through all attributes using a callback function and builds
 * an array of the returned values.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var result = group.attributes.map(function(array, i) {
 *     return value;
 * });&#x60;&#x60;&#x60;
 *
 * @for gdal.ArrayAttributes
 * @method map&lt;U&gt;
 * @param {mapCb&lt;gdal.Attribute,U&gt;} callback The callback to be called with each {{#crossLink &quot;Attribute&quot;}}Attribute{{/crossLink}}
 * @return {U[]}
 */
  gdal.ArrayAttributes.prototype.map = defaultMap

  /**
 * Iterates through all attributes using an iterator
 *
 * @example
 * &#x60;&#x60;&#x60;
 * for (const attribute of group.attributes) {
 * }
 *
 * @for gdal.ArrayAttributes
 * @type {gdal.Attribute}
 * @method Symbol.iterator
 */
  gdal.ArrayAttributes.prototype[Symbol.iterator] = defaultIterator
}

/**
 * Creates or opens a dataset. Dataset should be explicitly closed with &#x60;dataset.close()&#x60; method if opened in &#x60;&quot;w&quot;&#x60; mode to flush any changes. Otherwise, datasets are closed when (and if) node decides to garbage collect them.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var dataset = gdal.open(&#x27;./data.shp&#x27;);&#x60;&#x60;&#x60;
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var dataset = gdal.open(fs.readFileSync(&#x27;./data.shp&#x27;));&#x60;&#x60;&#x60;
 *
 * @for gdal
 * @throws Error
 * @method open
 * @static
 * @param {string|Buffer} path Path to dataset or in-memory Buffer to open
 * @param {string} [mode=&quot;r&quot;] The mode to use to open the file: &#x60;&quot;r&quot;&#x60;, &#x60;&quot;r+&quot;&#x60;, or &#x60;&quot;w&quot;&#x60;
 * @param {string|string[]} [drivers] Driver name, or list of driver names to attempt to use.
 *
 * @param {number} [x_size] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {number} [y_size] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {number} [band_count] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {string} [data_type] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {string[]|object} [creation_options] Used when creating a dataset with the &#x60;&quot;w&quot;&#x60; mode.
 *
 * @return {Dataset}
 */
gdal.open = (function () {
  const open = gdal.open

  // add &#x27;w&#x27; mode to gdal.open() method and also GDAL2-style driver selection
  return function (
    filename,
    mode,
    drivers /* , x_size, y_size, n_bands, datatype, options */
  ) {
    if (filename instanceof Buffer) {
      const buffer = filename
      arguments[0] = gdal.vsimem._anonymous(filename)
      const ds = gdal.open.apply(gdal, arguments)
      ds.buffer = buffer
      return ds
    }

    if (typeof drivers === &#x27;string&#x27;) {
      drivers = [ drivers ]
    } else if (drivers &amp;&amp; !Array.isArray(drivers)) {
      throw new Error(&#x27;driver(s) must be a string or list of strings&#x27;)
    }

    if (mode &amp;&amp; mode.includes &amp;&amp; mode.includes(&#x27;w&#x27;)) {
      // create file with given driver
      if (!drivers) {
        throw new Error(&#x27;Driver must be specified&#x27;)
      }
      if (drivers.length !== 1) {
        throw new Error(&#x27;Only one driver can be used to create a file&#x27;)
      }
      const driver = gdal.drivers.get(drivers[0])
      if (!driver) {
        throw new Error(&#x60;Cannot find driver: ${drivers[0]}&#x60;)
      }

      const args = Array.prototype.slice.call(arguments, 3) // x_size, y_size, ...
      args.unshift(filename)
      return driver.create.apply(driver, args)
    }

    if (arguments.length &gt; 2) {
      // open file with driver list
      // loop through given drivers trying to open file
      let ds
      drivers.forEach((driver_name) =&gt; {
        const driver = gdal.drivers.get(driver_name)
        if (!driver) {
          throw new Error(&#x60;Cannot find driver: ${driver_name}&#x60;)
        }
        try {
          ds = driver.open(filename, mode)
          return false
        } catch (err) {
          /* skip driver */
        }
      })

      if (!ds) throw new Error(&#x27;Error opening dataset&#x27;)
      return ds
    }

    // call gdal.open() method normally
    return open.apply(gdal, arguments)
  }
})()

const promisify = require(&#x27;util&#x27;).promisify
const callbackify = require(&#x27;util&#x27;).callbackify

/**
 * Asynchronously creates or opens a dataset. Dataset should be explicitly closed with &#x60;dataset.close()&#x60; method if opened in &#x60;&quot;w&quot;&#x60; mode to flush any changes. Otherwise, datasets are closed when (and if) node decides to garbage collect them.
 * If the last parameter is a callback, then this callback is called on completion and undefined is returned. Otherwise the function returns a Promise resolved with the result.
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var dataset = await gdal.openAsync(&#x27;./data.shp&#x27;);&#x60;&#x60;&#x60;
 *
 * @example
 * &#x60;&#x60;&#x60;
 * var dataset = await gdal.openAsync(await fd.readFile(&#x27;./data.shp&#x27;));&#x60;&#x60;&#x60;
 *
 * @example
 * &#x60;&#x60;&#x60;
 * gdal.openAsync(&#x27;./data.shp&#x27;, (err, ds) =&gt; {...});&#x60;&#x60;&#x60;
 *
 * @for gdal
 * @method openAsync
 * @static
 * @param {string|Buffer} path Path to dataset or in-memory Buffer to open
 * @param {string} [mode=&quot;r&quot;] The mode to use to open the file: &#x60;&quot;r&quot;&#x60;, &#x60;&quot;r+&quot;&#x60;, or &#x60;&quot;w&quot;&#x60;
 * @param {string|string[]} [drivers] Driver name, or list of driver names to attempt to use.
 *
 * @param {number} [x_size] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {number} [y_size] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {number} [band_count] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {string} [data_type] Used when creating a raster dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {string[]|object} [creation_options] Used when creating a dataset with the &#x60;&quot;w&quot;&#x60; mode.
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;Dataset&gt;}
 *
 */

/**
 * TypeScript shorthand version with callback and no optional arguments
 *
 * @for gdal
 * @method openAsync
 * @static
 * @param {string|Buffer} path Path to dataset or in-memory Buffer to open
 * @param {callback&lt;void&gt;} callback {{{cb}}}
 * @return {void}
 */

gdal.openAsync = (function () {
  const openPromise = (function () {
    const openPromise = promisify(gdal.openAsync)

    // add &#x27;w&#x27; mode to gdal.open() method and also GDAL2-style driver selection
    return function (
      filename,
      mode,
      drivers,
      _x_size,
      _y_size,
      _n_bands,
      _datatype,
      _options
    ) {
      if (filename instanceof Buffer) {
        const buffer = filename
        try {
          // vsimem._anonymous is always synchronous
          arguments[0] = gdal.vsimem._anonymous(filename)
        } catch (e) {
          return Promise.reject(e)
        }
        return gdal.openAsync.apply(gdal, arguments).then((ds) =&gt; {
          ds.buffer = buffer
          return ds
        })
      }
      if (typeof drivers === &#x27;string&#x27;) {
        drivers = [ drivers ]
      } else if (drivers &amp;&amp; !Array.isArray(drivers)) {
        throw new Error(&#x27;driver(s) must be a string or list of strings&#x27;)
      }

      if (mode === &#x27;w&#x27;) {
        // create file with given driver
        if (!drivers) {
          throw new Error(&#x27;Driver must be specified&#x27;)
        }
        if (drivers.length !== 1) {
          throw new Error(&#x27;Only one driver can be used to create a file&#x27;)
        }
        const driver = gdal.drivers.get(drivers[0])
        if (!driver) {
          throw new Error(&#x60;Cannot find driver: ${drivers[0]}&#x60;)
        }

        const args = Array.prototype.slice.call(arguments, 3) // x_size, y_size, ...
        args.unshift(filename)
        return gdal.Driver.prototype.createAsync.apply(driver, args)
      }

      if (arguments.length &gt; 2 &amp;&amp; drivers) {
        const p = []
        for (const driver_name of drivers) {
          const driver = gdal.drivers.get(driver_name)
          if (!driver) {
            throw new Error(&#x60;Cannot find driver: ${driver_name}&#x60;)
          }
          p.push(gdal.Driver.prototype.openAsync.call(driver, filename, mode))
        }
        // first driver to open the file wins
        // normally, there are no formats supported by two drivers
        return Promise.any(p).catch(() =&gt; {
          throw new Error(&#x27;Error opening dataset&#x27;)
        })
      }

      // call gdal.open() method normally
      return openPromise.call(gdal, filename, mode)
    }
  })()

  const openCb = callbackify(openPromise)
  return function (filename,
    mode,
    drivers,
    x_size,
    y_size,
    n_bands,
    datatype,
    options,
    callback) {
    if (typeof arguments[arguments.length - 1] === &#x27;function&#x27; &amp;&amp; callback === undefined) {
      callback = arguments[arguments.length - 1]
      arguments[arguments.length - 1] = undefined
    }
    if (callback) {
      const args = arguments
      Array.prototype.push.call(args, callback)
      return openCb.apply(gdal, args)
    }
    return openPromise.apply(gdal, arguments)
  }
})()

function fieldTypeFromValue(val) {
  const type = typeof val
  if (type === &#x27;number&#x27;) {
    if (val % 1 === 0) return gdal.OFTInteger
    return gdal.OFTReal
  } else if (type === &#x27;string&#x27;) {
    return gdal.OFTString
  } else if (type === &#x27;boolean&#x27;) {
    return gdal.OFTInteger
  } else if (val instanceof Date) {
    return gdal.OFTDateTime
  } else if (val instanceof Array) {
    const sub_type = fieldTypeFromValue(val[0])
    switch (sub_type) {
      case gdal.OFTString:
        return gdal.OFTStringList
      case gdal.OFTInteger:
        return gdal.OFTIntegerList
      case gdal.OFTReal:
        return gdal.OFTRealList
      default:
        throw new Error(&#x27;Array element cannot be converted into OGRFieldType&#x27;)
    }
  } else if (val instanceof Buffer) {
    return gdal.OFTBinary
  }

  throw new Error(&#x27;Value cannot be converted into OGRFieldType&#x27;)
}

/**
 * Creates a LayerFields instance from an object of keys and values.
 *
 * @method fromJSON
 * @for gdal.LayerFields
 * @param {object} object
 * @param {boolean} [approx_ok=false]
 */
gdal.LayerFields.prototype.fromJSON = (function () {
  let warned = false
  return function (obj, approx_ok) {
    if (!warned) {
      console.warn(
        &#x27;NODE-GDAL Deprecation Warning: LayerFields fromJSON() is deprecated, use fromObject() instead&#x27;
      )
      warned = true
    }
    return this.fromObject(obj, approx_ok)
  }
})()

gdal.LayerFields.prototype.fromObject = function (obj, approx_ok) {
  approx_ok = approx_ok || false
  Object.entries(obj).forEach(([ k, v ]) =&gt; {
    const type = fieldTypeFromValue(v)
    const def = new gdal.FieldDefn(k, type)
    this.add(def, approx_ok)
  })
}

/**
* @for gdal.Geometry
* @property wkbType
* @final
* @static
* @type {number}
*/
gdal.Point.wkbType = gdal.wkbPoint
gdal.LineString.wkbType = gdal.wkbLineString
gdal.LinearRing.wkbType = gdal.wkbLinearRing
if (gdal.CircularString) {
  gdal.CircularString.wkbType = gdal.wkbCircularString
  gdal.CompoundCurve.wkbType = gdal.wkbCompoundCurve
  gdal.MultiCurve.wkbType = gdal.wkbMultiCurve
}
gdal.Polygon.wkbType = gdal.wkbPolygon
gdal.MultiPoint.wkbType = gdal.wkbMultiPoint
gdal.MultiLineString.wkbType = gdal.wkbMultiLineString
gdal.MultiPolygon.wkbType = gdal.wkbMultiPolygon
gdal.GeometryCollection.wkbType = gdal.wkbGeometryCollection

// enable passing geometry constructors as the geometry type
gdal.DatasetLayers.prototype.create = (function () {
  const create = gdal.DatasetLayers.prototype.create
  return function (name, srs, geom_type /* , creation_options */) {
    if (arguments.length &gt; 2 &amp;&amp; geom_type instanceof Function) {
      if (typeof geom_type.wkbType === &#x27;undefined&#x27;) {
        throw new Error(&#x27;Function must be a geometry constructor&#x27;)
      }
      arguments[2] = geom_type.wkbType
    }
    return create.apply(this, arguments)
  }
})()

function getTypedArrayType(array) {
  if (array instanceof Uint8Array) return 1 // gdal.GDT_Byte
  if (array instanceof Int8Array) return 1 // gdal.GDT_Byte
  if (array instanceof Int16Array) return 3 // gdal.GDT_Int16
  if (array instanceof Uint16Array) return 2 // gdal.GDT_UInt16
  if (array instanceof Int32Array) return 5 // gdal.GDT_Int32
  if (array instanceof Uint32Array) return 4 // gdal.GDT_UInt32
  if (array instanceof Float32Array) return 6 // gdal.GDT_Float32
  if (array instanceof Float64Array) return 7 // gdal.GDT_Float64
  return 0 // gdal.GDT_Unknown
}

const mangleWrite = (args) =&gt; {
  let [ x, y, width, height, data, options ] = args
  if (!options) options = {}
  if (data) data._gdal_type = getTypedArrayType(data)
  return [
    x,
    y,
    width,
    height,
    data,
    options.buffer_width,
    options.buffer_height,
    options.pixel_space,
    options.line_space,
    options.progress_cb,
    options.offset
  ]
}

const mangleRead = (args) =&gt; {
  let [ x, y, width, height, data, options ] = args
  if (!options) options = {}
  if (data) data._gdal_type = getTypedArrayType(data)
  return [
    x,
    y,
    width,
    height,
    data,
    options.buffer_width,
    options.buffer_height,
    options.type,
    options.pixel_space,
    options.line_space,
    options.resampling,
    options.progress_cb,
    options.offset
  ]
}

const mangleBlock = (args) =&gt; {
  if (args[2]) args[2]._gdal_type = getTypedArrayType(args[2])
  return args
}

const mangleMDArray = (args) =&gt; {
  if (typeof args[0] === &#x27;object&#x27; &amp;&amp; typeof args[0].data === &#x27;object&#x27;) {
    args[0].data._gdal_type = getTypedArrayType(args[0].data)
  }
  return args
}

gdal.RasterBandPixels.prototype.read = (function () {
  const read = gdal.RasterBandPixels.prototype.read
  return function () {
    return read.apply(this, mangleRead(arguments))
  }
})()

gdal.RasterBandPixels.prototype.write = (function () {
  const write = gdal.RasterBandPixels.prototype.write
  return function () {
    return write.apply(this, mangleWrite(arguments))
  }
})()

gdal.RasterBandPixels.prototype.readBlock = (function () {
  const readBlock = gdal.RasterBandPixels.prototype.readBlock
  return function (x, y, data) {
    if (data) data._gdal_type = getTypedArrayType(data)
    return readBlock.apply(this, arguments)
  }
})()

gdal.RasterBandPixels.prototype.writeBlock = (function () {
  const writeBlock = gdal.RasterBandPixels.prototype.writeBlock
  return function (x, y, data) {
    data._gdal_type = getTypedArrayType(data)
    return writeBlock.apply(this, arguments)
  }
})()

if (gdal.MDArray) {
  gdal.MDArray.prototype.read = (function () {
    const read = gdal.MDArray.prototype.read
    return function () {
      return read.apply(this, mangleMDArray(arguments))
    }
  })()
}

const GroupCollection = {
  countAsync: 0,
  getAsync: 1
}

// Generic promisifiable methods and the argument number of their callbacks
const promisifiables = {
  Driver: {
    createAsync: 6,
    createCopyAsync: 5,
    openAsync: 2
  },
  Dataset: {
    flushAsync: 0,
    buildOverviewsAsync: 4,
    executeSQLAsync: 3
  },
  Layer: {
    flushAsync: 0
  },
  RasterBand: {
    flushAsync: 0,
    fillAsync: 2,
    computeStatisticsAsync: 1
  },
  RasterBandPixels: {
    readAsync: 13,
    writeAsync: 11,
    readBlockAsync: 3,
    writeBlockAsync: 3,
    getAsync: 2,
    setAsync: 3
  },
  DatasetLayers: {
    getAsync: 1,
    createAsync: 4,
    countAsync: 0,
    copyAsync: 3,
    removeAsync: 1
  },
  LayerFeatures: {
    getAsync: 1,
    setAsync: 2,
    firstAsync: 0,
    nextAsync: 0,
    addAsync: 1,
    countAsync: 1,
    removeAsync: 1
  },
  DatasetBands: {
    getAsync: 1,
    createAsync: 2,
    countAsync: 0
  },
  Geometry: {
    $fromWKTAsync: 2,
    $fromWKBAsync: 2,
    $fromGeoJsonAsync: 1,
    $fromGeoJsonBufferAsync: 1,
    toKMLAsync: 0,
    toGMLAsync: 0,
    toWKTAsync: 0,
    toWKBAsync: 2,
    toJSONAsync: 0,
    centroidAsync: 0,
    convexHullAsync: 0,
    boundaryAsync: 0,
    intersectionAsync: 1,
    flattenTo2DAsync: 0,
    unionAsync: 1,
    differenceAsync: 1,
    symDifferenceAsync: 1,
    simplifyAsync: 1,
    simplifyPreserveTopologyAsync: 1,
    bufferAsync: 2,
    getEnvelopeAsync: 0,
    getEnvelope3DAsync: 0,
    closeRingsAsync: 0,
    emptyAsync: 0,
    swapXYAsync: 0,
    isEmptyAsync: 0,
    isValidAsync: 0,
    makeValidAsync: 0,
    isSimpleAsync: 0,
    isRingAsync: 0,
    intersectsAsync: 1,
    equalsAsync: 1,
    disjointAsync: 1,
    touchesAsync: 1,
    crossesAsync: 1,
    withinAsync: 1,
    containsAsync: 1,
    overlapsAsync: 1,
    distanceAsync: 1,
    transformAsync: 1,
    transformToAsync: 1
  },
  MDArray: {
    readAsync: 1
  },
  GroupArrays: GroupCollection,
  GroupDimensions: GroupCollection,
  GroupAttributes: GroupCollection,
  GroupGroups: GroupCollection,
  ArrayDimensions: GroupCollection,
  ArrayAttributes: GroupCollection,
  $: {
    $fillNodataAsync: 1,
    $contourGenerateAsync: 1,
    $sieveFilterAsync: 1,
    $checksumImageAsync: 5,
    $polygonizeAsync: 1,
    $reprojectImageAsync: 1,
    $suggestedWarpOutputAsync: 1,
    $_acquireLocksAsync: 3
  }
}

const argMangle = {
  RasterBandPixels: {
    readAsync: mangleRead,
    writeAsync: mangleWrite,
    readBlockAsync: mangleBlock,
    writeBlockAsync: mangleBlock
  },
  MDArray: {
    readAsync: mangleMDArray
  }
}

// For each *Async function create a function that checks if the last parameter is a callback
// Then call either the original, either the promisified version with the callback
// placed at the right argument number since the C++ code does not support floating callbacks
for (const c of Object.keys(promisifiables)) {
  const klass = c === &#x27;$&#x27; ? gdal : gdal[c]
  if (klass === undefined) {
    continue
  }
  for (const _m of Object.keys(promisifiables[c])) {
    const { base, m } = _m.startsWith(&#x27;$&#x27;) ?
      { base: klass, m: _m.slice(1) } :
      { base: klass.prototype, m: _m }
    if (base[m] === undefined) {
      continue
    }
    base[m] = (function () {
      const promisified = promisify(base[m])
      const original = base[m]
      const cbArg = promisifiables[c][_m]
      const mangle = argMangle[c] &amp;&amp; argMangle[c][_m] ? argMangle[c][_m] : (a) =&gt; a
      return function () {
        let callback
        if (typeof arguments[arguments.length - 1] === &#x27;function&#x27;) {
          callback = arguments[arguments.length - 1]
          arguments[arguments.length - 1] = undefined
        }
        let args = Array.prototype.slice.call(mangle(arguments), 0, cbArg)
        if (callback) {
          args[cbArg] = callback
          return original.apply(this, args)
        }
        args = Object.assign(new Array(cbArg).fill(undefined), args)
        return promisified.apply(this, args)
      }
    })()
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
