<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/gdal_rasterband.cpp - node-gdal-async</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="node-gdal-async" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/GDALLogoColor.svg/200px-GDALLogoColor.svg.png" style="max-height: 65%;" title="node-gdal-async">
            node-gdal-async
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>3.4.3</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Constants (CPL Error Codes)", "classes/Constants (CPL Error Levels)", "classes/Constants (DCAP)", "classes/Constants (DIM)", "classes/Constants (DIR)", "classes/Constants (DMD)", "classes/Constants (GCI)", "classes/Constants (GDT)", "classes/Constants (GPI)", "classes/Constants (GRA)", "classes/Constants (ODsC)", "classes/Constants (OFT)", "classes/Constants (OJ)", "classes/Constants (OLC)", "classes/Constants (wkbByteOrder)", "classes/Constants (wkbGeometryType)", "classes/Constants (wkbVariant)", "classes/gdal", "classes/gdal.ArrayAttributes", "classes/gdal.ArrayDimensions", "classes/gdal.Attribute", "classes/gdal.CircularString", "classes/gdal.ColorTable", "classes/gdal.CompoundCurve", "classes/gdal.CompoundCurveCurves", "classes/gdal.config", "classes/gdal.CoordinateTransformation", "classes/gdal.Dataset", "classes/gdal.DatasetBands", "classes/gdal.DatasetLayers", "classes/gdal.Dimension", "classes/gdal.Driver", "classes/gdal.Envelope", "classes/gdal.Envelope3D", "classes/gdal.Feature", "classes/gdal.FeatureDefn", "classes/gdal.FeatureDefnFields", "classes/gdal.FeatureFields", "classes/gdal.FieldDefn", "classes/gdal.fs", "classes/gdal.GDALDrivers", "classes/gdal.Geometry", "classes/gdal.GeometryCollection", "classes/gdal.GeometryCollectionChildren", "classes/gdal.Group", "classes/gdal.GroupArrays", "classes/gdal.GroupAttributes", "classes/gdal.GroupDimensions", "classes/gdal.GroupGroups", "classes/gdal.Layer", "classes/gdal.LayerFeatures", "classes/gdal.LayerFields", "classes/gdal.LinearRing", "classes/gdal.LineString", "classes/gdal.LineStringPoints", "classes/gdal.MDArray", "classes/gdal.MultiCurve", "classes/gdal.MultiLineString", "classes/gdal.MultiPoint", "classes/gdal.MultiPolygon", "classes/gdal.Point", "classes/gdal.Polygon", "classes/gdal.PolygonRings", "classes/gdal.RasterBand", "classes/gdal.RasterBandOverviews", "classes/gdal.RasterBandPixels", "classes/gdal.RasterMuxStream", "classes/gdal.RasterReadStream", "classes/gdal.RasterTransform", "classes/gdal.RasterWriteStream", "classes/gdal.SimpleCurve", "classes/gdal.SpatialReference", "classes/gdal.vsimem"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/Constants (CPL Error Codes).html">Constants (CPL Error Codes)</a></li>
                <li><a href="../classes/Constants (CPL Error Levels).html">Constants (CPL Error Levels)</a></li>
                <li><a href="../classes/Constants (DCAP).html">Constants (DCAP)</a></li>
                <li><a href="../classes/Constants (DIM).html">Constants (DIM)</a></li>
                <li><a href="../classes/Constants (DIR).html">Constants (DIR)</a></li>
                <li><a href="../classes/Constants (DMD).html">Constants (DMD)</a></li>
                <li><a href="../classes/Constants (GCI).html">Constants (GCI)</a></li>
                <li><a href="../classes/Constants (GDT).html">Constants (GDT)</a></li>
                <li><a href="../classes/Constants (GPI).html">Constants (GPI)</a></li>
                <li><a href="../classes/Constants (GRA).html">Constants (GRA)</a></li>
                <li><a href="../classes/Constants (ODsC).html">Constants (ODsC)</a></li>
                <li><a href="../classes/Constants (OFT).html">Constants (OFT)</a></li>
                <li><a href="../classes/Constants (OJ).html">Constants (OJ)</a></li>
                <li><a href="../classes/Constants (OLC).html">Constants (OLC)</a></li>
                <li><a href="../classes/Constants (wkbByteOrder).html">Constants (wkbByteOrder)</a></li>
                <li><a href="../classes/Constants (wkbGeometryType).html">Constants (wkbGeometryType)</a></li>
                <li><a href="../classes/Constants (wkbVariant).html">Constants (wkbVariant)</a></li>
                <li><a href="../classes/gdal.html">gdal</a></li>
                <li><a href="../classes/gdal.ArrayAttributes.html">gdal.ArrayAttributes</a></li>
                <li><a href="../classes/gdal.ArrayDimensions.html">gdal.ArrayDimensions</a></li>
                <li><a href="../classes/gdal.Attribute.html">gdal.Attribute</a></li>
                <li><a href="../classes/gdal.CircularString.html">gdal.CircularString</a></li>
                <li><a href="../classes/gdal.ColorTable.html">gdal.ColorTable</a></li>
                <li><a href="../classes/gdal.CompoundCurve.html">gdal.CompoundCurve</a></li>
                <li><a href="../classes/gdal.CompoundCurveCurves.html">gdal.CompoundCurveCurves</a></li>
                <li><a href="../classes/gdal.config.html">gdal.config</a></li>
                <li><a href="../classes/gdal.CoordinateTransformation.html">gdal.CoordinateTransformation</a></li>
                <li><a href="../classes/gdal.Dataset.html">gdal.Dataset</a></li>
                <li><a href="../classes/gdal.DatasetBands.html">gdal.DatasetBands</a></li>
                <li><a href="../classes/gdal.DatasetLayers.html">gdal.DatasetLayers</a></li>
                <li><a href="../classes/gdal.Dimension.html">gdal.Dimension</a></li>
                <li><a href="../classes/gdal.Driver.html">gdal.Driver</a></li>
                <li><a href="../classes/gdal.Envelope.html">gdal.Envelope</a></li>
                <li><a href="../classes/gdal.Envelope3D.html">gdal.Envelope3D</a></li>
                <li><a href="../classes/gdal.Feature.html">gdal.Feature</a></li>
                <li><a href="../classes/gdal.FeatureDefn.html">gdal.FeatureDefn</a></li>
                <li><a href="../classes/gdal.FeatureDefnFields.html">gdal.FeatureDefnFields</a></li>
                <li><a href="../classes/gdal.FeatureFields.html">gdal.FeatureFields</a></li>
                <li><a href="../classes/gdal.FieldDefn.html">gdal.FieldDefn</a></li>
                <li><a href="../classes/gdal.fs.html">gdal.fs</a></li>
                <li><a href="../classes/gdal.GDALDrivers.html">gdal.GDALDrivers</a></li>
                <li><a href="../classes/gdal.Geometry.html">gdal.Geometry</a></li>
                <li><a href="../classes/gdal.GeometryCollection.html">gdal.GeometryCollection</a></li>
                <li><a href="../classes/gdal.GeometryCollectionChildren.html">gdal.GeometryCollectionChildren</a></li>
                <li><a href="../classes/gdal.Group.html">gdal.Group</a></li>
                <li><a href="../classes/gdal.GroupArrays.html">gdal.GroupArrays</a></li>
                <li><a href="../classes/gdal.GroupAttributes.html">gdal.GroupAttributes</a></li>
                <li><a href="../classes/gdal.GroupDimensions.html">gdal.GroupDimensions</a></li>
                <li><a href="../classes/gdal.GroupGroups.html">gdal.GroupGroups</a></li>
                <li><a href="../classes/gdal.Layer.html">gdal.Layer</a></li>
                <li><a href="../classes/gdal.LayerFeatures.html">gdal.LayerFeatures</a></li>
                <li><a href="../classes/gdal.LayerFields.html">gdal.LayerFields</a></li>
                <li><a href="../classes/gdal.LinearRing.html">gdal.LinearRing</a></li>
                <li><a href="../classes/gdal.LineString.html">gdal.LineString</a></li>
                <li><a href="../classes/gdal.LineStringPoints.html">gdal.LineStringPoints</a></li>
                <li><a href="../classes/gdal.MDArray.html">gdal.MDArray</a></li>
                <li><a href="../classes/gdal.MultiCurve.html">gdal.MultiCurve</a></li>
                <li><a href="../classes/gdal.MultiLineString.html">gdal.MultiLineString</a></li>
                <li><a href="../classes/gdal.MultiPoint.html">gdal.MultiPoint</a></li>
                <li><a href="../classes/gdal.MultiPolygon.html">gdal.MultiPolygon</a></li>
                <li><a href="../classes/gdal.Point.html">gdal.Point</a></li>
                <li><a href="../classes/gdal.Polygon.html">gdal.Polygon</a></li>
                <li><a href="../classes/gdal.PolygonRings.html">gdal.PolygonRings</a></li>
                <li><a href="../classes/gdal.RasterBand.html">gdal.RasterBand</a></li>
                <li><a href="../classes/gdal.RasterBandOverviews.html">gdal.RasterBandOverviews</a></li>
                <li><a href="../classes/gdal.RasterBandPixels.html">gdal.RasterBandPixels</a></li>
                <li><a href="../classes/gdal.RasterMuxStream.html">gdal.RasterMuxStream</a></li>
                <li><a href="../classes/gdal.RasterReadStream.html">gdal.RasterReadStream</a></li>
                <li><a href="../classes/gdal.RasterTransform.html">gdal.RasterTransform</a></li>
                <li><a href="../classes/gdal.RasterWriteStream.html">gdal.RasterWriteStream</a></li>
                <li><a href="../classes/gdal.SimpleCurve.html">gdal.SimpleCurve</a></li>
                <li><a href="../classes/gdal.SpatialReference.html">gdal.SpatialReference</a></li>
                <li><a href="../classes/gdal.vsimem.html">gdal.vsimem</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/gdal_rasterband.cpp <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">

#include &quot;gdal_common.hpp&quot;

#include &quot;collections/rasterband_overviews.hpp&quot;
#include &quot;collections/rasterband_pixels.hpp&quot;
#include &quot;collections/colortable.hpp&quot;
#include &quot;gdal_dataset.hpp&quot;
#include &quot;gdal_mdarray.hpp&quot;
#include &quot;gdal_majorobject.hpp&quot;
#include &quot;gdal_rasterband.hpp&quot;
#include &quot;utils/string_list.hpp&quot;

#include &lt;cpl_port.h&gt;
#include &lt;limits&gt;
#include &lt;mutex&gt;

namespace node_gdal {

Nan::Persistent&lt;FunctionTemplate&gt; RasterBand::constructor;

void RasterBand::Initialize(Local&lt;Object&gt; target) {
  Nan::HandleScope scope;

  Local&lt;FunctionTemplate&gt; lcons = Nan::New&lt;FunctionTemplate&gt;(RasterBand::New);
  lcons-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  lcons-&gt;SetClassName(Nan::New(&quot;RasterBand&quot;).ToLocalChecked());

  Nan::SetPrototypeMethod(lcons, &quot;toString&quot;, toString);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;flush&quot;, flush);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;fill&quot;, fill);
#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)
  Nan::SetPrototypeMethod(lcons, &quot;asMDArray&quot;, asMDArray);
#endif
  Nan::SetPrototypeMethod(lcons, &quot;getStatistics&quot;, getStatistics);
  Nan::SetPrototypeMethod(lcons, &quot;setStatistics&quot;, setStatistics);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;computeStatistics&quot;, computeStatistics);
  Nan::SetPrototypeMethod(lcons, &quot;getMaskBand&quot;, getMaskBand);
  Nan::SetPrototypeMethod(lcons, &quot;getMaskFlags&quot;, getMaskFlags);
  Nan::SetPrototypeMethod(lcons, &quot;createMaskBand&quot;, createMaskBand);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;getMetadata&quot;, getMetadata);
  Nan__SetPrototypeAsyncableMethod(lcons, &quot;setMetadata&quot;, setMetadata);
  ATTR_DONT_ENUM(lcons, &quot;ds&quot;, dsGetter, READ_ONLY_SETTER);
  ATTR_DONT_ENUM(lcons, &quot;_uid&quot;, uidGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;id&quot;, idGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;description&quot;, descriptionGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;size&quot;, sizeGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;overviews&quot;, overviewsGetter, READ_ONLY_SETTER);
  ATTR(lcons, &quot;pixels&quot;, pixelsGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;blockSize&quot;, blockSizeGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;minimum&quot;, minimumGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;maximum&quot;, maximumGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;readOnly&quot;, readOnlyGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;dataType&quot;, dataTypeGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;hasArbitraryOverviews&quot;, hasArbitraryOverviewsGetter, READ_ONLY_SETTER);
  ATTR_ASYNCABLE(lcons, &quot;unitType&quot;, unitTypeGetter, unitTypeSetter);
  ATTR_ASYNCABLE(lcons, &quot;scale&quot;, scaleGetter, scaleSetter);
  ATTR_ASYNCABLE(lcons, &quot;offset&quot;, offsetGetter, offsetSetter);
  ATTR_ASYNCABLE(lcons, &quot;noDataValue&quot;, noDataValueGetter, noDataValueSetter);
  ATTR_ASYNCABLE(lcons, &quot;categoryNames&quot;, categoryNamesGetter, categoryNamesSetter);
  ATTR_ASYNCABLE(lcons, &quot;colorInterpretation&quot;, colorInterpretationGetter, colorInterpretationSetter);
  ATTR_ASYNCABLE(lcons, &quot;colorTable&quot;, colorTableGetter, colorTableSetter);

  Nan::Set(target, Nan::New(&quot;RasterBand&quot;).ToLocalChecked(), Nan::GetFunction(lcons).ToLocalChecked());

  constructor.Reset(lcons);
}

RasterBand::RasterBand(GDALRasterBand *band) : Nan::ObjectWrap(), uid(0), this_(band), parent_ds(0) {
  LOG(&quot;Created band [%p] (dataset = %p)&quot;, band, band-&gt;GetDataset());
}

RasterBand::RasterBand() : Nan::ObjectWrap(), uid(0), this_(0), parent_ds(0) {
}

RasterBand::~RasterBand() {
  dispose();
}

void RasterBand::dispose() {
  if (this_) {
    LOG(&quot;Disposing band [%p]&quot;, this_);

    object_store.dispose(uid);

    LOG(&quot;Disposed band [%p]&quot;, this_);

    this_ = NULL;
  }
}

/**
 * A single raster band (or channel).
 *
 * @class gdal.RasterBand
 */
NAN_METHOD(RasterBand::New) {

  if (!info.IsConstructCall()) {
    Nan::ThrowError(&quot;Cannot call constructor as function, you need to use &#x27;new&#x27; keyword&quot;);
    return;
  }

  if (info[0]-&gt;IsExternal()) {
    Local&lt;External&gt; ext = info[0].As&lt;External&gt;();
    void *ptr = ext-&gt;Value();
    RasterBand *f = static_cast&lt;RasterBand *&gt;(ptr);
    f-&gt;Wrap(info.This());

    Local&lt;Value&gt; overviews = RasterBandOverviews::New(info.This());
    Nan::SetPrivate(info.This(), Nan::New(&quot;overviews_&quot;).ToLocalChecked(), overviews);
    Local&lt;Value&gt; pixels = RasterBandPixels::New(info.This());
    Nan::SetPrivate(info.This(), Nan::New(&quot;pixels_&quot;).ToLocalChecked(), pixels);

    info.GetReturnValue().Set(info.This());
    return;
  } else {
    Nan::ThrowError(&quot;Cannot create band directly create with dataset instead&quot;);
    return;
  }
}
Local&lt;Value&gt; RasterBand::New(GDALRasterBand *raw, GDALDataset *raw_parent) {
  Nan::EscapableHandleScope scope;

  if (!raw) { return scope.Escape(Nan::Null()); }
  if (object_store.has(raw)) { return scope.Escape(object_store.get(raw)); }

  RasterBand *wrapped = new RasterBand(raw);

  Local&lt;Value&gt; ext = Nan::New&lt;External&gt;(wrapped);
  Local&lt;Object&gt; obj =
    Nan::NewInstance(Nan::GetFunction(Nan::New(RasterBand::constructor)).ToLocalChecked(), 1, &amp;ext).ToLocalChecked();

  LOG(&quot;Adding band to cache[%p] (parent=%p)&quot;, raw, raw_parent);

  // add reference to dataset so dataset doesnt get GC&#x27;ed while band is alive
  // DONT USE GDALRasterBand.GetDataset() ... it will return a &quot;fake&quot; dataset
  // for overview bands
  // https://github.com/naturalatlas/node-gdal/blob/master/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp#L84

  Local&lt;Object&gt; ds;
  if (!object_store.has(raw_parent)) {
    LOG(&quot;Band&#x27;s parent dataset disappeared from cache (band = %p, dataset = %p)&quot;, raw, raw_parent);
    Nan::ThrowError(&quot;Band&#x27;s parent dataset disappeared from cache&quot;);
    return scope.Escape(Nan::Undefined());
    // ds = Dataset::New(raw_parent); //this should never happen
  }

  ds = object_store.get(raw_parent);
  Dataset *parent = Nan::ObjectWrap::Unwrap&lt;Dataset&gt;(ds);
  long parent_uid = parent-&gt;uid;
  wrapped-&gt;uid = object_store.add(raw, wrapped-&gt;persistent(), parent_uid);
  wrapped-&gt;parent_ds = raw_parent;
  wrapped-&gt;parent_uid = parent_uid;
  Nan::SetPrivate(obj, Nan::New(&quot;ds_&quot;).ToLocalChecked(), ds);

  return scope.Escape(obj);
}

NAN_METHOD(RasterBand::toString) {
  info.GetReturnValue().Set(Nan::New(&quot;RasterBand&quot;).ToLocalChecked());
}

/**
 * Saves changes to disk.
 * @method flush
 */

/**
 * Saves changes to disk.
 * {{{async}}}
 *
 * @method flushAsync
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 *
 */
NODE_WRAPPED_ASYNC_METHOD_WITH_OGRERR_RESULT_LOCKED(RasterBand, flush, FlushCache);

/**
 * Return the status flags of the mask band associated with the band.
 *
 * The result will be a bitwise OR-ed set of status flags with the following
 * available definitions that may be extended in the future:
 *
 *   - &#x60;GMF_ALL_VALID&#x60; (&#x60;0x01&#x60;): There are no invalid pixels, all mask values
 * will be 255. When used this will normally be the only flag set.
 *   - &#x60;GMF_PER_DATASET&#x60; (&#x60;0x02&#x60;): The mask band is shared between all bands on
 * the dataset.
 *   - &#x60;GMF_ALPHA&#x60; (&#x60;0x04&#x60;): The mask band is actually an alpha band and may
 * have values other than 0 and 255.
 *   - &#x60;GMF_NODATA&#x60; (&#x60;0x08&#x60;): Indicates the mask is actually being generated
 * from nodata values. (mutually exclusive of &#x60;GMF_ALPHA&#x60;)
 *
 * @method getMaskFlags
 * @return {number} Mask flags
 */
NODE_WRAPPED_METHOD_WITH_RESULT_LOCKED(RasterBand, getMaskFlags, Integer, GetMaskFlags);
// TODO: expose GMF constants in API
// ({{#crossLink &quot;Constants (GMF)&quot;}}see flags{{/crossLink}})

/**
 * Adds a mask band to the current band.
 *
 * @throws Error
 * @method createMaskBand
 * @param {number} flags Mask flags
 */
NODE_WRAPPED_METHOD_WITH_CPLERR_RESULT_1_INTEGER_PARAM_LOCKED(RasterBand, createMaskBand, CreateMaskBand, &quot;mask flags&quot;);
// TODO: expose GMF constants in API
// ({{#crossLink &quot;Constants (GMF)&quot;}}see flags{{/crossLink}})

/**
 * Return the mask band associated with the band.
 *
 * @method getMaskBand
 * @return {gdal.RasterBand}
 */
NAN_METHOD(RasterBand::getMaskBand) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  GDAL_LOCK_PARENT(band);
  GDALRasterBand *mask_band = band-&gt;this_-&gt;GetMaskBand();

  if (!mask_band) {
    info.GetReturnValue().Set(Nan::Null());
    return;
  }

  info.GetReturnValue().Set(RasterBand::New(mask_band, band-&gt;getParent()));
}

/**
 * Fill this band with a constant value.
 *
 * @throws Error
 * @method fill
 * @throws Error
 * @param {number} real_value
 * @param {number} [imaginary_value]
 */

/**
 * Fill this band with a constant value.
 * {{{async}}}
 *
 * @throws Error
 * @method fillAsync
 * @throws Error
 * @param {number} real_value
 * @param {number} [imaginary_value]
 * @param {callback&lt;void&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;void&gt;}
 */
GDAL_ASYNCABLE_DEFINE(RasterBand::fill) {
  double real, imaginary = 0;
  NODE_ARG_DOUBLE(0, &quot;real value&quot;, real);
  NODE_ARG_DOUBLE_OPT(1, &quot;imaginary value&quot;, real);

  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  GDALAsyncableJob&lt;CPLErr&gt; job(band-&gt;parent_uid);
  GDALRasterBand *gdal_obj = band-&gt;this_;

  job.main = [gdal_obj, real, imaginary](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    CPLErr err = gdal_obj-&gt;Fill(real, imaginary);
    if (err) { throw CPLGetLastErrorMsg(); }
    return err;
  };
  job.rval = [](CPLErr, const GetFromPersistentFunc &amp;) { return Nan::Undefined().As&lt;Value&gt;(); };

  job.run(info, async, 2);
}

// --- Custom error handling to handle VRT errors ---
// see: https://github.com/mapbox/mapnik-omnivore/issues/10

std::mutex stats_lock;
std::string stats_file_err = &quot;&quot;;
CPLErrorHandler last_err_handler;
void CPL_STDCALL statisticsErrorHandler(CPLErr eErrClass, int err_no, const char *msg) {
  if (err_no == CPLE_OpenFailed) { stats_file_err = msg; }
  if (last_err_handler) { last_err_handler(eErrClass, err_no, msg); }
}
void pushStatsErrorHandler() {
  last_err_handler = CPLSetErrorHandler(statisticsErrorHandler);
}
void popStatsErrorHandler() {
  if (!last_err_handler) return;
  CPLSetErrorHandler(last_err_handler);
}

/**
 * Return a view of this raster band as a 2D multidimensional GDALMDArray.
 *
 * The band must be linked to a GDALDataset.
 *
 * If the dataset has a geotransform attached, the X and Y dimensions of the returned array will have an associated indexing variable.
 *
 * Requires GDAL&gt;=3.3 with MDArray support, won&#x27;t be defined otherwise
 *
 * @throws Error
 * @method asMDArray
 * @return {gdal.MDArray}
 */
#if GDAL_VERSION_MAJOR &gt; 3 || (GDAL_VERSION_MAJOR == 3 &amp;&amp; GDAL_VERSION_MINOR &gt;= 1)
NAN_METHOD(RasterBand::asMDArray) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  GDAL_RAW_CHECK(GDALRasterBand *, band, raw);
  GDAL_LOCK_PARENT(band);
  CPLErrorReset();
  std::shared_ptr&lt;GDALMDArray&gt; mdarray = raw-&gt;AsMDArray();
  if (mdarray == nullptr) {
    Nan::ThrowError(CPLGetLastErrorMsg());
    return;
  }
  Local&lt;Value&gt; obj = MDArray::New(mdarray, band-&gt;parent_ds);
  info.GetReturnValue().Set(obj);
}
#endif

/**
 * Fetch image statistics.
 *
 * Returns the minimum, maximum, mean and standard deviation of all pixel values
 * in this band. If approximate statistics are sufficient, the
 * &#x60;allow_approximation&#x60; argument can be set to &#x60;true&#x60; in which case overviews,
 * or a subset of image tiles may be used in computing the statistics.
 *
 * @throws Error
 * @method getStatistics
 * @param {boolean} allow_approximation If &#x60;true&#x60; statistics may be computed
 * based on overviews or a subset of all tiles.
 * @param {boolean} force If &#x60;false&#x60; statistics will only be returned if it can
 * be done without rescanning the image.
 * @return {object} Statistics containing &#x60;&quot;min&quot;&#x60;, &#x60;&quot;max&quot;&#x60;, &#x60;&quot;mean&quot;&#x60;,
 * &#x60;&quot;std_dev&quot;&#x60; properties.
 */
NAN_METHOD(RasterBand::getStatistics) {
  double min, max, mean, std_dev;
  int approx, force;
  NODE_ARG_BOOL(0, &quot;allow approximation&quot;, approx);
  NODE_ARG_BOOL(1, &quot;force&quot;, force);
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  GDAL_LOCK_PARENT(band);
  pushStatsErrorHandler();
  CPLErr err = band-&gt;this_-&gt;GetStatistics(approx, force, &amp;min, &amp;max, &amp;mean, &amp;std_dev);
  popStatsErrorHandler();
  if (!stats_file_err.empty()) {
    Nan::ThrowError(stats_file_err.c_str());
  } else if (err) {
    if (!force &amp;&amp; err == CE_Warning) {
      Nan::ThrowError(&quot;Statistics cannot be efficiently computed without scanning raster&quot;);
      return;
    }
    NODE_THROW_LAST_CPLERR;
    return;
  }

  Local&lt;Object&gt; result = Nan::New&lt;Object&gt;();
  Nan::Set(result, Nan::New(&quot;min&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(min));
  Nan::Set(result, Nan::New(&quot;max&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(max));
  Nan::Set(result, Nan::New(&quot;mean&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(mean));
  Nan::Set(result, Nan::New(&quot;std_dev&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(std_dev));

  info.GetReturnValue().Set(result);
}

/**
 * Computes image statistics.
 *
 * Returns the minimum, maximum, mean and standard deviation of all pixel values
 * in this band. If approximate statistics are sufficient, the
 * &#x60;allow_approximation&#x60; argument can be set to &#x60;true&#x60; in which case overviews,
 * or a subset of image tiles may be used in computing the statistics.
 *
 * @throws Error
 * @method computeStatistics
 * @param {boolean} allow_approximation If &#x60;true&#x60; statistics may be computed
 * based on overviews or a subset of all tiles.
 * @return {stats} Statistics containing &#x60;&quot;min&quot;&#x60;, &#x60;&quot;max&quot;&#x60;, &#x60;&quot;mean&quot;&#x60;,
 * &#x60;&quot;std_dev&quot;&#x60; properties.
 */

/**
 * Computes image statistics.
 * {{async}}
 *
 * Returns the minimum, maximum, mean and standard deviation of all pixel values
 * in this band. If approximate statistics are sufficient, the
 * &#x60;allow_approximation&#x60; argument can be set to &#x60;true&#x60; in which case overviews,
 * or a subset of image tiles may be used in computing the statistics.
 *
 * @throws Error
 * @method computeStatisticsAsync
 * @param {boolean} allow_approximation If &#x60;true&#x60; statistics may be computed
 * based on overviews or a subset of all tiles.
 * @param {callback&lt;stats&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;stats&gt;} Statistics containing &#x60;&quot;min&quot;&#x60;, &#x60;&quot;max&quot;&#x60;, &#x60;&quot;mean&quot;&#x60;,
 * &#x60;&quot;std_dev&quot;&#x60; properties.
 */
GDAL_ASYNCABLE_DEFINE(RasterBand::computeStatistics) {
  struct stats_t {
    double min, max, mean, std_dev;
  };
  int approx;

  NODE_ARG_BOOL(0, &quot;allow approximation&quot;, approx);
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  GDALAsyncableJob&lt;stats_t&gt; job(band-&gt;parent_uid);
  GDALRasterBand *gdal_obj = band-&gt;this_;

  job.main = [gdal_obj, approx](const GDALExecutionProgress &amp;) {
    struct stats_t stats;
    std::lock_guard&lt;std::mutex&gt; guard(stats_lock);

    CPLErrorReset();
    pushStatsErrorHandler();
    CPLErr err = gdal_obj-&gt;ComputeStatistics(approx, &amp;stats.min, &amp;stats.max, &amp;stats.mean, &amp;stats.std_dev, NULL, NULL);
    popStatsErrorHandler();
    if (!stats_file_err.empty()) {
      throw stats_file_err.c_str();
    } else if (err != CPLE_None) {
      throw CPLGetLastErrorMsg();
    }

    return stats;
  };

  job.rval = [](stats_t r, const GetFromPersistentFunc &amp;) {
    Nan::EscapableHandleScope scope;
    Local&lt;Object&gt; result = Nan::New&lt;Object&gt;();
    Nan::Set(result, Nan::New(&quot;min&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(r.min));
    Nan::Set(result, Nan::New(&quot;max&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(r.max));
    Nan::Set(result, Nan::New(&quot;mean&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(r.mean));
    Nan::Set(result, Nan::New(&quot;std_dev&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(r.std_dev));
    return scope.Escape(result);
  };

  job.run(info, async, 1);
}

/**
 * Set statistics on the band. This method can be used to store
 * min/max/mean/standard deviation statistics.
 *
 * @throws Error
 * @method setStatistics
 * @param {number} min
 * @param {number} max
 * @param {number} mean
 * @param {number} std_dev
 */
NAN_METHOD(RasterBand::setStatistics) {
  double min, max, mean, std_dev;

  NODE_ARG_DOUBLE(0, &quot;min&quot;, min);
  NODE_ARG_DOUBLE(1, &quot;max&quot;, max);
  NODE_ARG_DOUBLE(2, &quot;mean&quot;, mean);
  NODE_ARG_DOUBLE(3, &quot;standard deviation&quot;, std_dev);
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  GDAL_LOCK_PARENT(band);
  CPLErr err = band-&gt;this_-&gt;SetStatistics(min, max, mean, std_dev);

  if (err) {
    NODE_THROW_LAST_CPLERR;
    return;
  }
  return;
}

/**
 * Returns band metadata
 *
 * @method getMetadata
 * @param {string} [domain]
 * @return {any}
 */

/**
 * Returns band metadata.
 * {{{async}}}
 *
 * @method getMetadataAsync
 * @param {string} [domain]
 * @param {callback&lt;any&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;any&gt;}
 */
GDAL_ASYNCABLE_DEFINE(RasterBand::getMetadata) {

  std::string domain(&quot;&quot;);
  NODE_ARG_OPT_STR(0, &quot;domain&quot;, domain);
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  GDAL_RAW_CHECK(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;char **&gt; job(band-&gt;parent_uid);
  job.main = [raw, domain](const GDALExecutionProgress &amp;) {
    return raw-&gt;GetMetadata(domain.empty() ? nullptr : domain.c_str());
  };
  job.rval = [](char **md, const GetFromPersistentFunc &amp;) { return MajorObject::getMetadata(md); };
  job.run(info, async, 1);
}

/**
 * Set metadata. Can return a warning (false) for formats not supporting persistent metadata.
 *
 * @method setMetadata
 * @param {object|string[]} metadata
 * @param {string} [domain]
 * @return {boolean}
 */

/**
 * Set metadata. Can return a warning (false) for formats not supporting persistent metadata.
 * {{{async}}}
 *
 * @method setMetadataAsync
 * @param {object|string[]} metadata
 * @param {string} [domain]
 * @param {callback&lt;boolean&gt;} [callback=undefined] {{{cb}}}
 * @return {Promise&lt;boolean&gt;}
 */
GDAL_ASYNCABLE_DEFINE(RasterBand::setMetadata) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  GDAL_RAW_CHECK(GDALRasterBand *, band, raw);

  auto options = make_shared&lt;StringList&gt;();
  if (info.Length() == 0 || options-&gt;parse(info[0])) {
    Nan::ThrowError(&quot;Failed parsing metadata&quot;);
    return;
  }

  std::string domain(&quot;&quot;);
  NODE_ARG_OPT_STR(1, &quot;domain&quot;, domain);

  GDALAsyncableJob&lt;CPLErr&gt; job(band-&gt;parent_uid);
  job.main = [raw, options, domain](const GDALExecutionProgress &amp;) {
    CPLErr r = raw-&gt;SetMetadata(options-&gt;get(), domain.empty() ? nullptr : domain.c_str());
    if (r == CE_Failure) throw CPLGetLastErrorMsg();
    return r;
  };
  job.rval = [](CPLErr r, const GetFromPersistentFunc &amp;) { return Nan::New&lt;Boolean&gt;(r == CE_None); };
  job.run(info, async, 2);
}

/**
 * @readOnly
 * @attribute ds
 * @type {gdal.Dataset}
 */
NAN_GETTER(RasterBand::dsGetter) {
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;ds_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute overviews
 * @type {gdal.RasterBandOverviews}
 */
NAN_GETTER(RasterBand::overviewsGetter) {
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;overviews_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute pixels
 * @type {gdal.RasterBandPixels}
 */
NAN_GETTER(RasterBand::pixelsGetter) {
  info.GetReturnValue().Set(Nan::GetPrivate(info.This(), Nan::New(&quot;pixels_&quot;).ToLocalChecked()).ToLocalChecked());
}

/**
 * @readOnly
 * @attribute id
 * @type {number|null}
 */

/**
 * @readOnly
 * @attribute idAsync
 * @type {Promise&lt;number|null&gt;}
 * {{{async_getter}}}
 */

GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::idGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;int&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    return raw-&gt;GetBand();
  };
  job.rval = [](int id, const GetFromPersistentFunc &amp;) {
    if (id == 0) return Nan::Null().As&lt;Value&gt;();
    return Nan::New&lt;Integer&gt;(id).As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * Name of of band.
 *
 * @readOnly
 * @attribute description
 * @type {string}
 */

/**
 * Name of of band.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute descriptionAsync
 * @type {Promise&lt;string&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::descriptionGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;const char *&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) { return raw-&gt;GetDescription(); };
  job.rval = [](const char *desc, const GetFromPersistentFunc &amp;) { return SafeString::New(desc); };
  job.run(info, async);
}

/**
 * Size object containing &#x60;&quot;x&quot;&#x60; and &#x60;&quot;y&quot;&#x60; properties.
 *
 * @readOnly
 * @attribute size
 * @type {xyz}
 */

/**
 * Size object containing &#x60;&quot;x&quot;&#x60; and &#x60;&quot;y&quot;&#x60; properties.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute sizeAsync
 * @type {Promise&lt;xyz&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::sizeGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  struct xy {
    int x, y;
  };
  GDALAsyncableJob&lt;xy&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    xy r;
    r.x = raw-&gt;GetXSize();
    r.y = raw-&gt;GetYSize();
    return r;
  };
  job.rval = [](xy r, const GetFromPersistentFunc &amp;) {
    Nan::EscapableHandleScope scope;
    Local&lt;Object&gt; result = Nan::New&lt;Object&gt;();
    Nan::Set(result, Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;(r.x));
    Nan::Set(result, Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;(r.y));
    return scope.Escape(result);
  };
  job.run(info, async);
}

/**
 * Size object containing &#x60;&quot;x&quot;&#x60; and &#x60;&quot;y&quot;&#x60; properties.
 *
 * @readOnly
 * @attribute blockSize
 * @type {xyz}
 */

/**
 * Size object containing &#x60;&quot;x&quot;&#x60; and &#x60;&quot;y&quot;&#x60; properties.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute blockSizeAsync
 * @type {Promise&lt;xyz&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::blockSizeGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  struct xy {
    int x, y;
  };
  GDALAsyncableJob&lt;xy&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    xy r;
    raw-&gt;GetBlockSize(&amp;r.x, &amp;r.y);
    return r;
  };
  job.rval = [](xy r, const GetFromPersistentFunc &amp;) {
    Nan::EscapableHandleScope scope;
    Local&lt;Object&gt; result = Nan::New&lt;Object&gt;();
    Nan::Set(result, Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;(r.x));
    Nan::Set(result, Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;(r.y));
    return scope.Escape(result);
  };
  job.run(info, async);
}

template &lt;typename T&gt; struct MaybeResult {
  T value;
  int success;
};

/**
 * Minimum value for this band.
 *
 * @readOnly
 * @attribute minimum
 * @type {number|null}
 */

/**
 * Minimum value for this band.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute minimumAsync
 * @type {Promise&lt;number|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::minimumGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;MaybeResult&lt;double&gt;&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    MaybeResult&lt;double&gt; r;
    CPLErrorReset();
    r.value = raw-&gt;GetMinimum(&amp;r.success);
    return r;
  };
  job.rval = [](MaybeResult&lt;double&gt; r, const GetFromPersistentFunc &amp;) {
    if (r.success) return Nan::New&lt;Number&gt;(r.value).As&lt;Value&gt;();
    return Nan::Null().As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * Maximum value for this band.
 *
 * @readOnly
 * @attribute maximum
 * @type {number|null}
 */

/**
 * Maximum value for this band.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute maximumAsync
 * @type {Promise&lt;number|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::maximumGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;MaybeResult&lt;double&gt;&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    MaybeResult&lt;double&gt; r;
    CPLErrorReset();
    r.value = raw-&gt;GetMaximum(&amp;r.success);
    return r;
  };
  job.rval = [](MaybeResult&lt;double&gt; r, const GetFromPersistentFunc &amp;) {
    if (r.success) return Nan::New&lt;Number&gt;(r.value).As&lt;Value&gt;();
    return Nan::Null().As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * Raster value offset.
 *
 * @attribute offset
 * @type {number|null}
 */

/**
 * Raster value offset.
 * {{{async_getter}}}
 *
 * @attribute offsetAsync
 * @readOnly
 * @type {Promise&lt;number|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::offsetGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;MaybeResult&lt;double&gt;&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    MaybeResult&lt;double&gt; r;
    CPLErrorReset();
    r.value = raw-&gt;GetOffset(&amp;r.success);
    return r;
  };
  job.rval = [](MaybeResult&lt;double&gt; r, const GetFromPersistentFunc &amp;) {
    if (r.success) return Nan::New&lt;Number&gt;(r.value).As&lt;Value&gt;();
    return Nan::Null().As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * Raster value scale.
 *
 * @attribute scale
 * @type {number|null}
 */

/**
 * Raster value scale.
 * {{{async_getter}}}
 *
 * @attribute scaleAsync
 * @readOnly
 * @type {Promise&lt;number|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::scaleGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;MaybeResult&lt;double&gt;&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    MaybeResult&lt;double&gt; r;
    CPLErrorReset();
    r.value = raw-&gt;GetScale(&amp;r.success);
    return r;
  };
  job.rval = [](MaybeResult&lt;double&gt; r, const GetFromPersistentFunc &amp;) {
    if (r.success) return Nan::New&lt;Number&gt;(r.value).As&lt;Value&gt;();
    return Nan::Null().As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * No data value for this band.
 *
 * @attribute noDataValue
 * @type {number|null}
 */

/**
 * No data value for this band.
 * {{{async_getter}}}
 *
 * @attribute noDataValueAsync
 * @readOnly
 * @type {Promise&lt;number|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::noDataValueGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;MaybeResult&lt;double&gt;&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    MaybeResult&lt;double&gt; r;
    CPLErrorReset();
    r.value = raw-&gt;GetNoDataValue(&amp;r.success);
    return r;
  };
  job.rval = [](MaybeResult&lt;double&gt; r, const GetFromPersistentFunc &amp;) {
    if (r.success)
      return Nan::New&lt;Number&gt;(r.value).As&lt;Value&gt;();
    else
      return Nan::Null().As&lt;Value&gt;();
  };
  job.run(info, async);
}

/**
 * Raster unit type (name for the units of this raster&#x27;s values).
 * For instance, it might be &#x60;&quot;m&quot;&#x60; for an elevation model in meters,
 * or &#x60;&quot;ft&quot;&#x60; for feet. If no units are available, a value of &#x60;&quot;&quot;&#x60;
 * will be returned.
 *
 * @attribute unitType
 * @type {string|null}
 */

/**
 * Raster unit type (name for the units of this raster&#x27;s values).
 * For instance, it might be &#x60;&quot;m&quot;&#x60; for an elevation model in meters,
 * or &#x60;&quot;ft&quot;&#x60; for feet. If no units are available, a value of &#x60;&quot;&quot;&#x60;
 * will be returned.
 * {{{async_getter}}}
 *
 * @attribute unitTypeAsync
 * @readOnly
 * @type {Promise&lt;string|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::unitTypeGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;const char *&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    return raw-&gt;GetUnitType();
  };
  job.rval = [](const char *r, const GetFromPersistentFunc &amp;) { return SafeString::New(r); };
  job.run(info, async);
}

/**
 *
 * Pixel data type ({{#crossLink &quot;Constants (GDT)&quot;}}see GDT
 * constants{{/crossLink}}) used for this band.
 *
 * @readOnly
 * @attribute dataType
 * @type {string|null}
 */

/**
 *
 * Pixel data type ({{#crossLink &quot;Constants (GDT)&quot;}}see GDT
 * constants{{/crossLink}}) used for this band.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute dataTypeAsync
 * @type {Promise&lt;string|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::dataTypeGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;GDALDataType&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    return raw-&gt;GetRasterDataType();
  };
  job.rval = [](GDALDataType type, const GetFromPersistentFunc &amp;) {
    if (type == GDT_Unknown) return Nan::Null().As&lt;Value&gt;();
    return SafeString::New(GDALGetDataTypeName(type));
  };
  job.run(info, async);
}

/**
 * Indicates if the band is read-only.
 *
 * @readOnly
 * @attribute readOnly
 * @type {boolean}
 */

/**
 * Indicates if the band is read-only.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute readOnlyAsync
 * @type {Promise&lt;boolean&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::readOnlyGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;GDALAccess&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    return raw-&gt;GetAccess();
  };
  job.rval = [](GDALAccess r, const GetFromPersistentFunc &amp;) { return (r == GA_Update ? Nan::False() : Nan::True()); };
  job.run(info, async);
}

/**
 * An indicator if the underlying datastore can compute arbitrary overviews
 * efficiently, such as is the case with OGDI over a network. Datastores with
 * arbitrary overviews don&#x27;t generally have any fixed overviews, but GDAL&#x27;s
 * &#x60;RasterIO()&#x60; method can be used in downsampling mode to get overview
 * data efficiently.
 *
 * @readOnly
 * @attribute hasArbitraryOverviews
 * @type {boolean}
 */

/**
 * An indicator if the underlying datastore can compute arbitrary overviews
 * efficiently, such as is the case with OGDI over a network. Datastores with
 * arbitrary overviews don&#x27;t generally have any fixed overviews, but GDAL&#x27;s
 * &#x60;RasterIO()&#x60; method can be used in downsampling mode to get overview
 * data efficiently.
 * {{{async_getter}}}
 *
 * @readOnly
 * @attribute hasArbitraryOverviewsAsync
 * @type {Promise&lt;boolean&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::hasArbitraryOverviewsGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;bool&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    CPLErrorReset();
    return static_cast&lt;bool&gt;(raw-&gt;HasArbitraryOverviews());
  };
  job.rval = [](bool r, const GetFromPersistentFunc &amp;) { return Nan::New&lt;Boolean&gt;(r); };
  job.run(info, async);
}

/**
 * List of list of category names for this raster.
 *
 * @attribute categoryNames
 * @type {string[]}
 */

/**
 * List of list of category names for this raster.
 * {{{async_getter}}}
 *
 * @attribute categoryNamesAsync
 * @readOnly
 * @type {Promise&lt;string[]&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::categoryNamesGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) {
    auto names = std::make_shared&lt;std::vector&lt;std::string&gt;&gt;();
    CPLErrorReset();
    // Here we copy twice what we could have copied only once
    // In practice, GetCategoryNames always returns the same buffer
    // But in theory, a clever driver could implement some crazy lazy method
    // So we do everything &quot;The Right Way&quot;
    // This is not a performance-critical function anyway
    char **raw_names = raw-&gt;GetCategoryNames();
    int i = 0;

    while (raw_names != nullptr &amp;&amp; raw_names[i] != nullptr) {
      names-&gt;push_back(raw_names[i]);
      i++;
    }
    return names;
  };
  job.rval = [](std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; names, const GetFromPersistentFunc &amp;) {
    Nan::EscapableHandleScope scope;
    Local&lt;Array&gt; results = Nan::New&lt;Array&gt;();
    for (std::size_t i = 0; i &lt; names-&gt;size(); ++i) Nan::Set(results, i, SafeString::New((*names.get())[i].c_str()));
    return scope.Escape(results);
  };
  job.run(info, async);
}

/**
 * Color interpretation mode ({{#crossLink &quot;Constants (GCI)&quot;}}see GCI
 * constants{{/crossLink}}).
 *
 * @attribute colorInterpretation
 * @type {string|null}
 */

/**
 * Color interpretation mode ({{#crossLink &quot;Constants (GCI)&quot;}}see GCI
 * constants{{/crossLink}}).
 * {{{async_getter}}}
 *
 * @attribute colorInterpretationAsync
 * @readOnly
 * @type {Promise&lt;string|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::colorInterpretationGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);
  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;GDALColorInterp&gt; job(band-&gt;parent_uid);
  job.persist(&quot;this&quot;, info.This());
  job.main = [raw](const GDALExecutionProgress &amp;) { return raw-&gt;GetColorInterpretation(); };
  job.rval = [](GDALColorInterp ci, const GetFromPersistentFunc &amp;) {
    if (ci == GCI_Undefined)
      return Nan::Undefined().As&lt;Value&gt;();
    else
      return SafeString::New(GDALGetColorInterpretationName(ci));
  };

  job.run(info, async);
}

NAN_SETTER(RasterBand::unitTypeSetter) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);
  if (!value-&gt;IsString()) {
    Nan::ThrowError(&quot;Unit type must be a string&quot;);
    return;
  }
  std::string input = *Nan::Utf8String(value);
  GDAL_LOCK_PARENT(band);
  CPLErr err = band-&gt;this_-&gt;SetUnitType(input.c_str());
  if (err) { NODE_THROW_LAST_CPLERR; }
}

NAN_SETTER(RasterBand::noDataValueSetter) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  CPLErr err;
  GDAL_LOCK_PARENT(band);
  CPLErrorReset();
  if (value-&gt;IsNull() || value-&gt;IsUndefined()) {
    err = band-&gt;this_-&gt;DeleteNoDataValue();
  } else if (value-&gt;IsNumber()) {
    err = band-&gt;this_-&gt;SetNoDataValue(Nan::To&lt;double&gt;(value).ToChecked());
  } else {
    Nan::ThrowError(&quot;No data value must be a number&quot;);
    return;
  }

  if (err != CE_None) { NODE_THROW_LAST_CPLERR; }
}

NAN_SETTER(RasterBand::scaleSetter) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  if (!value-&gt;IsNumber()) {
    Nan::ThrowError(&quot;Scale must be a number&quot;);
    return;
  }
  double input = Nan::To&lt;double&gt;(value).ToChecked();
  GDAL_LOCK_PARENT(band);
  CPLErr err = band-&gt;this_-&gt;SetScale(input);
  if (err) { NODE_THROW_LAST_CPLERR; }
}

NAN_SETTER(RasterBand::offsetSetter) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  if (!value-&gt;IsNumber()) {
    Nan::ThrowError(&quot;Offset must be a number&quot;);
    return;
  }
  double input = Nan::To&lt;double&gt;(value).ToChecked();
  GDAL_LOCK_PARENT(band);
  CPLErr err = band-&gt;this_-&gt;SetOffset(input);
  if (err) { NODE_THROW_LAST_CPLERR; }
}

NAN_SETTER(RasterBand::categoryNamesSetter) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  if (!value-&gt;IsArray()) {
    Nan::ThrowError(&quot;Category names must be an array&quot;);
    return;
  }
  Local&lt;Array&gt; names = value.As&lt;Array&gt;();

  char **list = NULL;
  std::shared_ptr&lt;std::string&gt; strlist;

  if (names-&gt;Length() &gt; 0) {
    list = new char *[names-&gt;Length() + 1];
    strlist = std::shared_ptr&lt;std::string&gt;(new std::string[names-&gt;Length()], array_deleter&lt;std::string&gt;());
    unsigned int i;
    for (i = 0; i &lt; names-&gt;Length(); i++) {
      strlist.get()[i] = *Nan::Utf8String(Nan::Get(names, i).ToLocalChecked());
      list[i] = (char *)strlist.get()[i].c_str();
    }
    list[i] = NULL;
  }

  GDAL_LOCK_PARENT(band);
  int err = band-&gt;this_-&gt;SetCategoryNames(list);

  if (list) { delete[] list; }

  if (err) { NODE_THROW_LAST_CPLERR; }
}

NAN_SETTER(RasterBand::colorInterpretationSetter) {
  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  GDALColorInterp ci = GCI_Undefined;

  if (value-&gt;IsString()) {
    std::string name = *Nan::Utf8String(value);
    ci = GDALGetColorInterpretationByName(name.c_str());
  } else if (!value-&gt;IsNull() &amp;&amp; !value-&gt;IsUndefined()) {
    Nan::ThrowError(&quot;color interpretation must be a string or undefined&quot;);
    return;
  }

  GDAL_LOCK_PARENT(band);
  CPLErr err = band-&gt;this_-&gt;SetColorInterpretation(ci);
  if (err) { NODE_THROW_LAST_CPLERR; }
}

/**
 * Color table ({{#crossLink &quot;ColorTable&quot;}}see gdal.ColorTable{{/crossLink}}).
 *
 * @attribute colorTable
 * @type {gdal.ColorTable|null}
 */

/**
 * Color table ({{#crossLink &quot;ColorTable&quot;}}see gdal.ColorTable{{/crossLink}}).
 * {{{async_getter}}}
 *
 * @attribute colorTableAsync
 * @readOnly
 * @type {Promise&lt;gdal.ColorTable|null&gt;}
 */
GDAL_ASYNCABLE_GETTER_DEFINE(RasterBand::colorTableGetter) {
  NODE_UNWRAP_CHECK_ASYNC(RasterBand, info.This(), band);

  GDAL_RAW_CHECK_ASYNC(GDALRasterBand *, band, raw);

  GDALAsyncableJob&lt;GDALColorTable *&gt; job(band-&gt;parent_uid);
  job.main = [raw](const GDALExecutionProgress &amp;) { return raw-&gt;GetColorTable(); };
  job.rval = [](GDALColorTable *ct, const GetFromPersistentFunc &amp;getter) {
    if (ct != nullptr) return ColorTable::New(ct, getter(&quot;this&quot;));
    return Nan::Undefined().As&lt;Value&gt;();
  };

  job.run(info, async);
}

NAN_SETTER(RasterBand::colorTableSetter) {

  NODE_UNWRAP_CHECK(RasterBand, info.This(), band);

  GDALColorTable *raw;
  if (value-&gt;IsNullOrUndefined()) {
    raw = nullptr;
  } else if (IS_WRAPPED(value, ColorTable)) {
    NODE_UNWRAP_CHECK(ColorTable, value.As&lt;Object&gt;(), ct);
    GDAL_RAW_CHECK(GDALColorTable *, ct, _raw);
    raw = _raw;
  } else {
    Nan::ThrowTypeError(&quot;color table must be a gdal.ColorTable object or null&quot;);
    return;
  }

  GDAL_LOCK_PARENT(band);
  CPLErr err = band-&gt;this_-&gt;SetColorTable(raw);
  if (err != CE_None) { NODE_THROW_LAST_CPLERR; }
}

NAN_GETTER(RasterBand::uidGetter) {
  RasterBand *band = Nan::ObjectWrap::Unwrap&lt;RasterBand&gt;(info.This());
  info.GetReturnValue().Set(Nan::New((int)band-&gt;uid));
}

} // namespace node_gdal

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
